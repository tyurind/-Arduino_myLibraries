																										//
#ifndef iarduino_Metro_KEY_h																			//	Функции работы с кнопкой.
#define iarduino_Metro_KEY_h																			//
																										//
class iarduino_Metro_KEY: public iarduino_Metro_BASE{													//	Определяем производный класс iarduino_Metro_KEY.
	public:																								//
	/**	функции данного производного класса iarduino_Metro_KEY		**/									//
	/**	дублирую функции полиморфного класса iarduino_Metro_BASE	**/									//
																										//
//		Функции не используемые в данном модуле:														//
		bool	begin			(int i0=NOT2, int i1=NOT2	){return 0;}								//	Инициализация модуля.
		int		test			(int i0=NOT2, int i1=NOT2	){return 0;}								//	Самотестирование модуля.
																										//
//		Выполняем действия:																				//
		bool	action			(int i0=NOT2, int i1=NOT2	){											//	Объявляем функцию выполнения действий.
								uint8_t data[6] = {0,0,0,0,0,0};										//	Определяем массив для хранения данных пакетно считываемых/записываемых в модуль.
								bool    result  = false;												//	Определяем флаг результата возвращаемый функцией action.
								uint8_t sumtry  = 10;													//	Количество попыток чтения/записи.
								switch(i0){																//
								//	Действие № 0 - установить время TIME_HOLD для флагов HOLD:			//
									case 0:																//
										data[0]		 =	uint8_t(time_hold1/100);						//	Определяем время удержания кнопки требуемое для установки флага HOLD_1.
										data[1]		 =	uint8_t(time_hold2/100);						//	Определяем время удержания кнопки требуемое для установки флага HOLD_2.
										data[2]		 =	uint8_t(time_hold3/100);						//	Определяем время удержания кнопки требуемое для установки флага HOLD_3.
										do{	result	 =	objI2C.writeBytes( i1, REG_DATA+2, data, 3);	//	Записываем 3 элемента массива data в модуль с адресом i1, начиная с регистра REG_DATA+2.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																//
								//	Действие № 1 - прочитать состояние кнопки:							//
									case 1:																//
										do{	result	 =	objI2C.readBytes( i1, REG_DATA, data, 6);		//	Читаем 6 байт из модуля с адресом i1, начиная с регистра REG_DATA в массив data.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
										pushed		|=	bool		(	data[0] & bit(7)	);			//	Устанавливаем флаг события   кнопки - «нажимается».                                              Если флаг pushed   был установлен, то он и останется установленным!
										released	|=	bool		(	data[0] & bit(6)	);			//	Устанавливаем флаг события   кнопки - «отпускается».                                             Если флаг released был установлен, то он и останется установленным!
										pressed		 =	bool		(	data[0] & bit(5)	);			//	Определяем    флаг состояния кнопки - «нажата».
										trigger		 =	bool		(	data[0] & bit(4)	);			//	Определяем    флаг состояния кнопки - «переключена» (меняет состояние с каждым новым нажатием).
										hold3		 =	bool		(	data[0] & bit(3)	);			//	Определяем    флаг состояния кнопки - «удерживается» дольше чем время TIME_HOLD3.
										hold2		 =	bool		(	data[0] & bit(2)	);			//	Определяем    флаг состояния кнопки - «удерживается» дольше чем время TIME_HOLD2.
										hold1		 =	bool		(	data[0] & bit(1)	);			//	Определяем    флаг состояния кнопки - «удерживается» дольше чем время TIME_HOLD1.
										changed		|=	bool		(	data[0] & bit(0)	);			//	Устанавливаем флаг события   кнопки - «состояние изменилось».                                    Если флаг changed  был установлен, то он и останется установленным!
										time		 =	uint16_t	(	data[1] 			) * 100;	//	Определяем время удержания текущего состояния кнопки (нажата или отпущена) в мс (от 0 до 25500 мс, с шагом 100 мс).
										sum			 =					data[5];						//	Определяем количество нажатий на кнопку после последнего обращения к функции read().
									//	Устранение повторных срабатываний флагов						//	Если проверить флаг в условии if() а потом прочитать данные, то флаг будет прочтён и в условии и при чтении данных, а значит сработает при следующем проходе цикла.
										if(pushed | released | changed){delay(20);}						//	Если установлен флаг pushed «нажимается», released «отпускается», или changed «состояние изменилось», то ждём 20 мс. В течении этого времени указанный(ые) бит(ы) будет сброшен в модуле.
									break;																//
								}																		//
								return result;															//
		}																								//
																										//
//		Получаем значение переменных:																	//
		void	setVar			(int i0=NOT2, int i1=NOT2	){											//
								switch(i0){																//
									case 0: 	time_hold1	= i1;						break;			//	Получаем время удержания кнопки требуемое для установки флага HOLD_1:   0...25500 =  0,0...25,5 сек.
									case 1: 	time_hold2	= i1;						break;			//	Получаем время удержания кнопки требуемое для установки флага HOLD_2:   0...25500 =  0,0...25,5 сек.
									case 2:		time_hold3	= i1;						break;			//	Получаем время удержания кнопки требуемое для установки флага HOLD_3:   0...25500 =  0,0...25,5 сек.
								}																		//
		}																								//
																										//
//		Возвращаем значение переменных:																	//
		long	getVar			(int i0=NOT2){															//
								bool f=0;																//	Объявляем временную переменную для вывода флагов, значение которых должно обнуляться после вывода.
								switch(i0){																//
									case 0:		f=pushed;	pushed=0;	return long(f);			break;	//  Возвращаем флаг события   кнопки - «нажимается».                                              Флаг pushed   сбрасывается после отправки своего значения.
									case 1:		f=released;	released=0;	return long(f);			break;	//  Возвращаем флаг события   кнопки - «отпускается».                                             Флаг released сбрасывается после отправки своего значения.
									case 2:								return long(pressed);	break;	//	Возвращаем флаг состояния кнопки - «нажата».
									case 3:								return long(trigger);	break;	//	Возвращаем флаг состояния кнопки - «переключена» (меняет состояние с каждым новым нажатием).
									case 4:								return long(hold3);		break;	//	Возвращаем флаг состояния кнопки - «удерживается» дольше чем время TIME_HOLD3.
									case 5:								return long(hold2);		break;	//	Возвращаем флаг состояния кнопки - «удерживается» дольше чем время TIME_HOLD2.
									case 6:								return long(hold1);		break;	//	Возвращаем флаг состояния кнопки - «удерживается» дольше чем время TIME_HOLD1.
									case 7:		f=changed;	changed=0;	return long(f);			break;	//	Возвращаем флаг события   кнопки - «состояние изменилось».                                    Флаг changed  сбрасывается после отправки своего значения.
									case 8:								return long(time);		break;	//	Возвращаем время удержания текущего состояния кнопки (нажата или отпущена) в мс (от 0 до 25500 мс, с шагом 100 мс).
									case 9:								return long(sum);		break;	//	Возвращаем количество нажатий на кнопку после последнего обращения к функции read().
									default:							return 0;				break;	//
								}																		//
		}																								//
																										//
	private:																							//
	/**	Внутренние переменные **/																		//
		bool		pushed		= 0;																	//	Определяем переменную для хранения события кнопки: нажимается.
		bool		released	= 0;																	//	Определяем переменную для хранения события кнопки: отпускается.
		bool		pressed;																			//	Объявляем  переменную для хранения состояния кнопки:	нажата.
		bool		trigger;																			//	Объявляем  переменную для хранения состояния кнопки:	переключена (меняет состояние с каждым новым нажатием).
		bool		hold3;																				//	Объявляем  переменную для хранения флага указывающего на удержание кнопки дольше времени TIME_HOLD3.
		bool		hold2;																				//	Объявляем  переменную для хранения флага указывающего на удержание кнопки дольше времени TIME_HOLD2.
		bool		hold1;																				//	Объявляем  переменную для хранения флага указывающего на удержание кнопки дольше времени TIME_HOLD1.
		bool		changed		= 0;																	//	Определяем переменную для хранения флага указывающего на смену состояния кнопки.
		uint16_t	time;																				//	Объявляем  переменную для хранения времени удержания или простоя кнопки (времени удержания текущего состояния флага pressed).
        uint16_t	time_hold3;																			//	Объявляем  переменную для хранения времени удержания кнопки, которое требуется для установки флага HOLD_3.
        uint16_t	time_hold2;																			//	Объявляем  переменную для хранения времени удержания кнопки, которое требуется для установки флага HOLD_2.
        uint16_t	time_hold1;																			//	Объявляем  переменную для хранения времени удержания кнопки, которое требуется для установки флага HOLD_1.
		uint8_t		sum;																				//	Объявляем  переменную для хранения количества нажатий на кнопку.
};																										//
																										//
#endif																									//

/* =======================================================================================================================================================================================================

Действия функций библиотеки:

set(время1,время2,время3)              - установка времени для срабатывания флагов hold. Время указывается в миллисекундах (от 0 до 25500 мс, с шагом 100 мс).
                                         TIME_HOLD_1 = время1 / 1000
                                         TIME_HOLD_2 = время2 / 1000
                                         TIME_HOLD_3 = время3 / 1000
read( [ параметр     ] )               - считывает все данные о кнопке, а возвращаемое значение зависит от параметра функции (по умолчанию KEY_PRESSED):
        KEY_PUSHED                     - вернуть флаг     PUSHED   регистра REG_DATA. Если данный флаг был установлен ранее, но не был прочитан, то функция read( KEY_PUSHED   ) вернёт 1 вне зависимости от текущего значения флага PUSHED.
        KEY_RELEASED                   - вернуть флаг     RELEASED регистра REG_DATA. Если данный флаг был установлен ранее, но не был прочитан, то функция read( KEY_RELEASED ) вернёт 1 вне зависимости от текущего значения флага RELEASED.
        KEY_PRESSED                    - вернуть флаг     PRESSED  регистра REG_DATA.
        KEY_TRIGGER                    - вернуть флаг     TRIGGER  регистра REG_DATA.
        KEY_HOLD3                      - вернуть флаг     HOLD_3   регистра REG_DATA.
        KEY_HOLD2                      - вернуть флаг     HOLD_2   регистра REG_DATA.
        KEY_HOLD1                      - вернуть флаг     HOLD_1   регистра REG_DATA.
        KEY_CHANGED                    - вернуть флаг     CHANGED  регистра REG_DATA. Если данный флаг был установлен ранее, но не был прочитан, то функция read( KEY_CHANGED ) вернёт 1 вне зависимости от текущего значения флага CHANGED.
        KEY_TIME                       - вернуть время    TIME     регистра REG_DATA+1. Время возвращается в миллисекундах (от 0 до 25500 мс, с шагом 100 мс).
        KEY_SUM                        - вернуть значение SUM      регистра REG_DATA+5.

Таблица регистров модуля:

                   ╔══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤═════════════════════════════════════════════════════════════╗
                   ║       7      │       6      │       5      │       4      │       3      │       2      │       1      │       0      │                                                             ║
                   ╠══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪═════════════════════════════════════════════════════════════╣
0x00 REG_FLAGS_0   ║  FLG_RESET   │FLG_SELF_TEST │       -      │       -      │       -      │       -      │GET_PIN_ADDRES│GET_PIN_OUTPUT│ Служебные флаги для чтения.                                 ║
0x01 REG_BITS_0    ║  SET_RESET   │SET_SELF_TEST │       -      │       -      │       -      │       -      │       -      │SET_PIN_OUTPUT│ Служебные флаги для записи.                                 ║
0x02 REG_FLAGS_1   ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для чтения.                                 ║
0x03 REG_BITS_1    ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для записи.                                 ║
                   ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x04 REG_MODEL   █ ║                                                             MODEL  [7-0] = 0x01 - кнопка                              │ Тип датчика                                                 ║
0x05 REG_VERSION   ║                                                             VERSION[7-0] = 0x00                                       │ Версия прошивки                                             ║
0x06 REG_ADDRESS   ║                                                             ADDRESS[6-0] = 0x09                        │ IF_PIN_ADDRES│ Текущий адрес на шине                                       ║
0x07 REG_CHIP_ID   ║                                                             CHIP_ID[7-0] = 0xC3                                       │ ID линейки чипов                                            ║
                   ╟───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────╢
0x08 REG_WRITE     ║                                                             WRITE_0[7-0]                                              │ Зарезервирован                                              ║
0x09 REG_WRITE+1   ║                                                             WRITE_1[7-0]                                              │ Зарезервирован                                              ║
0x0A REG_WRITE+2   ║                                                             WRITE_2[7-0]                                              │ Зарезервирован                                              ║
0x0B REG_WRITE+3   ║                                                             WRITE_3[7-0]                                              │ Зарезервирован                                              ║
0x0C REG_WRITE+4   ║                                                             WRITE_4[7-0]                                              │ Зарезервирован                                              ║
0x0D REG_WRITE+5   ║                                                             WRITE_5[7-0]                                              │ Зарезервирован                                              ║
0x0E REG_WRITE+6   ║                                                             WRITE_6[7-0]                                              │ Зарезервирован                                              ║
0x0F REG_WRITE+7   ║                                                             WRITE_7[7-0]                                              │ Зарезервирован                                              ║
                   ╟──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┼─────────────────────────────────────────────────────────────╢
0x10 REG_DATA    █ ║    PUSHED    │   RELEASED   │    PRESSED   │    TRIGGER   │    HOLD_3    │    HOLD_2    │    HOLD_1    │   CHANGED    │ Статусные флаги                                             ║
                 █ ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x11 REG_DATA+1  █ ║                                                             TIME[7-0]                                                 │ Время удержания/простоя кнопки                              ║
0x12 REG_DATA+2  █ ║                                                             TIME_HOLD_1[7-0]                                          │ Время удержания для флага HOLD_1                            ║
0x13 REG_DATA+3  █ ║                                                             TIME_HOLD_2[7-0]                                          │ Время удержания для флага HOLD_2                            ║
0x14 REG_DATA+4  █ ║                                                             TIME_HOLD_3[7-0]                                          │ Время удержания для флага HOLD_3                            ║
0x15 REG_DATA+5  █ ║                                                             SUM[7-0]                                                  │ Количество нажатий после последнего чтения данного регистра ║
                   ╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╧═════════════════════════════════════════════════════════════╝

PUSHED      - Флаг указывает что кнопка нажимается. Сбрасывается аппаратно после чтения регистра REG_DATA.
RELEASED    - Флаг указывает что кнопка отпускается. Сбрасывается аппаратно после чтения регистра REG_DATA.
PRESSED     - Флаг указывает что кнопка нажата. Сбрасывается при отпускании кнопки.
TRIGGER     - Флаг меняется с каждым новым нажатием на кнопку.
HOLD_X      - флаг указывает что кнопку удерживается дольше чем время указанного в «TIME_HOLD_X». Сбрасывается при отпускании кнопки.
CHANGED     - флаг указывающий на то, что показания кнопки изменились после последнего чтения данного регистра. Сбрасывается аппаратно после чтения регистра REG_DATA.
TIME        - Время удержания или простоя кнопки, в зависимости от состояния флага «PRESSED» (время в десятых долях секунд: от 0.0 до 25.5 сек.).
TIME_HOLD_X - Время удержания кнопки по истечении которого устанавливается флаг HOLD_X  (время в десятых долях секунд: от 0.0 до 25.5 сек.).
SUM         - Количество нажатий на кнопку выполненное с последнего чтения регистра REG_DATA+5.

*/