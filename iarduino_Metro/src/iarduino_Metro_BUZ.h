																										//
#ifndef iarduino_Metro_BUZ_h																			//	Функции работы со звукоизлучателем.
#define iarduino_Metro_BUZ_h																			//
																										//
class iarduino_Metro_BUZ: public iarduino_Metro_BASE{													//	Определяем производный класс iarduino_Metro_BUZ.
	public:																								//
	/**	функции данного производного класса iarduino_Metro_BUZ		**/									//
	/**	дублирую функции полиморфного класса iarduino_Metro_BASE	**/									//
																										//
//		Функции не используемые в данном модуле:														//
		bool	begin			(int i0=NOT2, int i1=NOT2	){return 0;}								//	Инициализация модуля.
		int		test			(int i0=NOT2, int i1=NOT2	){return 0;}								//	Самотестирование модуля.
		long	getVar			(int i0=NOT2				){return 0;}								//	Возврат значений переменных.
																										//
//		Выполняем действия:																				//
		bool	action			(int i0=NOT2, int i1=NOT2	){											//	
								uint8_t data[7] = {0,0,0,0,0,0,0};										//	Определяем массив для хранения данных пакетно записываемых в модуль.
								bool result     = false;												//	Определяем флаг результата возвращаемый функцией action.
								uint8_t sumtry  = 10;													//	Количество попыток чтения/записи.
								if(melody_end || i0==0){												//	Если установлен флаг melody_end или требуется выполнить действие № 0 (отключить тональный сигнал), то ...
								//	Отключаем воспроизведение мелодии:									//
									do{	result = objI2C.writeByte( i1, REG_DATA+6,0);					//	Записываем 0 в регистр REG_DATA+6 (MELODY) модуля с адресом i1.
										sumtry	--;	if(!result){delay(1);}								//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
									}	while		(!result && sumtry>0);								//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									delay(50);															//
									melody_end=false; 													//	Сбрасываем флаг melody_end.
								}																		//
								switch(i0){																//
								//	Действие № 0 - отключить тональный сигнал:							//
									case 0:																//
										do{	result = objI2C.writeBytes( i1, REG_DATA, data, 6);			//	Записываем 6 элементов массива data в модуль с адресом i1, начиная с регистра REG_DATA.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																//
								//	Действие № 1 - включить тональный сигнал или мелодию:				//
									case 1:																//
										if(melody){														//	Если задан номер мелодии, то...
											data[6] = melody;											//	Определяем номер выполняемой мелодии.
											do{	result = objI2C.writeBytes( i1, REG_DATA, data, 7);		//	Записываем 7 элементов массива data в модуль с адресом i1, начиная с регистра REG_DATA.
												sumtry	--;	if(!result){delay(1);}						//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);						//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
										}else{															//
											data[0] = 1;												//	Устанавливаем статусный флаг START.
											data[0]|= ((time_on!=NOT2 && time_off==NOT2)?0:1)<<1;		//	Определяем статусный флаг BLINK: если тональный сигнал включается на указанное время (длительность указана, а пауза нет), то сбрасываем флаг, иначе устанавливаем.
											data[1] = uint8_t( freq_tone							);	//	Определяем частоту тонального сигнала (младший бит).
											data[2] = uint8_t( freq_tone >> 8						);	//	Определяем частоту тонального сигнала (старший бит).
											data[3] = uint8_t((time_on ==NOT2)? 1:(time_on /100)	);	//	Определяем время длительности тонального сигнала.
											data[4] = uint8_t((time_off==NOT2)? 0:(time_off/100)	);	//	Определяем время паузы между тональными сигналами.
											data[5] = uint8_t((sum     ==NOT2)? 0: sum          	);	//	Определяем количество повторов тональных сигналов.
											if(freq_tone<10){memset(data,0,6);}							//	Если частота ниже 10 Гц, то выключаем звукоизлучатель.
											do{	result = objI2C.writeBytes( i1, REG_DATA, data, 6);		//	Записываем 6 элементов массива data в модуль с адресом i1, начиная с регистра REG_DATA.
												sumtry	--;	if(!result){delay(1);}						//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);						//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
										}																//
									break;																//
								}																		//
								return result;															//
		}																								//
																										//
//		Получаем значение переменных:																	//
		void	setVar			(int i0=NOT2, int i1=NOT2	){											//
								bool f = bool(melody);													//	Устанавливаем флаг f если сейчас воспроизводится мелодия.
								switch(i0){																//
									case 0: melody		= i1;		break;								//	Получаем номер мелодии, которую требуется воспроизвести:		0...255   =  0...255 мелодия.
									case 1: freq_tone	= i1;		break;								//	Получаем частоту тонального сигнала:							0...32767 =  0...32767 Гц
									case 2: time_on		= i1;		break;								//	Получаем время длительности тонального сигнала:					0...25500 =  0,0...25,5 сек.
									case 3: time_off	= i1;		break;								//	Получаем время паузы между тональными сигналами:				0...25500 =  0,0...25,5 сек.
									case 4: sum			= i1;		break;								//	Получаем количество повторов тональных сигналов:				0...255   =  0...255 раз.
								}																		//
								if(f){ if(melody==0){	melody_end = true; }}							//	Если мелодия воспроизводилась, а теперь нет, то устанавливаем флаг melody_end.
		}																								//
																										//
	private:																							//
	/**	Внутренние переменные **/																		//
		int		freq_tone;																				//	Объявляем переменную для хранения частоты тонального сигнала:								0...32767 =  0...32767 Гц
		int		time_on;																				//	Объявляем переменную для хранения времени длительности тонального сигнала:					0...255   =  0,0...25,5 сек.
		int		time_off;																				//	Объявляем переменную для хранения времени паузы между тональными сигналами:					0...255   =  0,0...25,5 сек.
		int		sum;																					//	Объявляем переменную для хранения количества повторов тональных сигналов:					0...255   =  0...255 раз.
		int		melody;																					//	Объявляем переменную для хранения номера воспроизводимой мелодии:							0...255   =  0...255   мелодия.
		bool	melody_end=1;																			//	Определяем флаг указывающий на необходимость завершить воспроизведение мелодии.
};																										//
																										//
long MELODY(uint8_t num){																				//
	return 0x7F000000L + num;																			//
}																										//
																										//
#endif																									//

/* =======================================================================================================================================================================================================

Действия функций библиотеки:

off();                                     - отключить звук               BLINK=X START=0 TIME_ON=X TIME_OFF=X START_BLINK_SUM=0
on();                                      - включить звук 3кГц постоянно BLINK=1 START=1 TIME_ON>0 TIME_OFF=0 START_BLINK_SUM=0
on(частота);                               - включить звук постоянно      BLINK=1 START=1 TIME_ON>0 TIME_OFF=0 START_BLINK_SUM=0
on(частота,длительность);                  - включить на указанное время  BLINK=0 START=1 TIME_ON>0 TIME_OFF=0 START_BLINK_SUM=0
on(частота,длительность,пауза);            - постоянно повторять          BLINK=1 START=1 TIME_ON>0 TIME_OFF>0 START_BLINK_SUM=0
on(частота,длительность,пауза,количество); - повторять указанное кол. раз BLINK=X START=X TIME_ON>0 TIME_OFF>0 START_BLINK_SUM>0

Назначение дополнительных режимов работы звукоизлучателя:

MELODY = 0 - обычный режим работы звукоизлучателя
MELODY = 1 - режим воспроизведения мелодии 1
MELODY = 2 - режим воспроизведения мелодии 2
MELODY = 3 - режим воспроизведения мелодии 3 ...

Таблица регистров модуля:

                   ╔══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤═════════════════════════════════════════════════════════════╗
                   ║       7      │       6      │       5      │       4      │       3      │       2      │       1      │       0      │                                                             ║
                   ╠══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪═════════════════════════════════════════════════════════════╣
0x00 REG_FLAGS_0   ║  FLG_RESET   │FLG_SELF_TEST │       -      │       -      │       -      │       -      │GET_PIN_ADDRES│GET_PIN_OUTPUT│ Служебные флаги для чтения.                                 ║
0x01 REG_BITS_0    ║  SET_RESET   │SET_SELF_TEST │       -      │       -      │       -      │       -      │       -      │SET_PIN_OUTPUT│ Служебные флаги для записи.                                 ║
0x02 REG_FLAGS_1   ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для чтения.                                 ║
0x03 REG_BITS_1    ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для записи.                                 ║
                   ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x04 REG_MODEL   █ ║                                                             MODEL  [7-0] = 0x04 - звукоизлучатель                     │ Тип датчика                                                 ║
0x05 REG_VERSION   ║                                                             VERSION[7-0] = 0x00                                       │ Версия прошивки                                             ║
0x06 REG_ADDRESS   ║                                                             ADDRESS[6-0] = 0x09                        │ IF_PIN_ADDRES│ Текущий адрес на шине                                       ║
0x07 REG_CHIP_ID   ║                                                             CHIP_ID[7-0] = 0xC3                                       │ ID линейки чипов                                            ║
                   ╟───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────╢
0x08 REG_WRITE     ║                                                             WRITE_0[7-0]                                              │ Зарезервирован                                              ║
0x09 REG_WRITE+1   ║                                                             WRITE_1[7-0]                                              │ Зарезервирован                                              ║
0x0A REG_WRITE+2   ║                                                             WRITE_2[7-0]                                              │ Зарезервирован                                              ║
0x0B REG_WRITE+3   ║                                                             WRITE_3[7-0]                                              │ Зарезервирован                                              ║
0x0C REG_WRITE+4   ║                                                             WRITE_4[7-0]                                              │ Зарезервирован                                              ║
0x0D REG_WRITE+5   ║                                                             WRITE_5[7-0]                                              │ Зарезервирован                                              ║
0x0E REG_WRITE+6   ║                                                             WRITE_6[7-0]                                              │ Зарезервирован                                              ║
0x0F REG_WRITE+7   ║                                                             WRITE_7[7-0]                                              │ Зарезервирован                                              ║
                   ╟──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┼─────────────────────────────────────────────────────────────╢
0x10 REG_DATA;   █ ║       -      │       -      │       -      │       -      │       -      │       -      │    BLINK     │    START     │ Статусные флаги                                             ║
                 █ ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x11 REG_DATA+1  █ ║                                                             FREQUENCY[ 7-0] = 0xD0                                    │ Частота меандра в Гц (младший байт)                         ║
0x12 REG_DATA+2  █ ║                                                             FREQUENCY[15-8] = 0x07       0x07D0 = 2000 Гц = 2 кГц     │ Частота меандра в Гц (старший байт)                         ║
0x13 REG_DATA+3  █ ║                                                             TIME_ON[7-0]    = 0x01 = 01 = 0,1 сек.                    │ Время в течении которого ШИМ должен быть установлен.        ║
0x14 REG_DATA+4  █ ║                                                             TIME_OFF[7-0]   = 0x00 = 00 = 0,0 сек.                    │ Время в течении которого нужно отключить звук.              ║
0x15 REG_DATA+5  █ ║                                                             START_BLINK_SUM[7-0]                                      │ Количество повторов (сколько раз выполнить цикл TIME_ON_OFF)║
0x16 REG_DATA+6  █ ║                                                             MELODY[7-0]                                               │ Проигрывание мелодий (статусные флаги игнорируются).        ║
                   ╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╧═════════════════════════════════════════════════════════════╝

FREQUENCY        - Частота тона (меандра) в Гц.
BLINK            - Флаг указывает установить флаг START после его сброса.
START            - Флаг указывает установить тон и начать отсчет времени TIME_ON + TIME_OFF после чего сбросить флаг START.
                   Установка бита START - приведёт к установке тона и началу отсчёта времени TIME_ON + TIME_OFF.
                   Сброс     бита START - приведёт прекращению отсчёта времени TIME_ON + TIME_OFF и отключению тона вне зависимости от состояния флага BLINK.
TIME_ON          - Время в течении которого тон должен звучать       (время в десятых долях секунд: от 0.0 до 25.5 сек.).
TIME_OFF         - Время в течении которого тон должен быть выключен (время в десятых долях секунд: от 0.0 до 25.5 сек.).
START_BLINK_SUM  - Запись ненулевого значения установит флаг START и сбросит флаг BLINK, но модуль будет вести себя так, как будто флаг BLINK установлен.
                   С каждым циклом TIME_ON + TIME_OFF значение регистра START_BLINK_SUM будет уменьшаться, пока не достигнет 0, тогда флаг START будет сброшен.
MELODY           - Режим проигрывания мелодий. Если установлено значение больше 0, то флаги регистра 0x10 игнорируются.
                   MELODY=0 - обычный режим работы звукоизлучателя, MELODY>0 воспроизведение мелодии, номер которой указан в регистре MELODY.

*/