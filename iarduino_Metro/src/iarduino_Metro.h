//	Библиотека для работы с модулями линейки «метро».
//  Версия: 1.0.0
//  Последнюю версию библиотеки Вы можете скачать по ссылке: http://iarduino.ru/file/489.html
//  Подробное описание функции бибилиотеки доступно по ссылке: http://iarduino.ru/file/489.html
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел.
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru
																									//
#ifndef iarduino_Metro_h																			//
#define iarduino_Metro_h																			//
																									//
#if defined(ARDUINO) && (ARDUINO >= 100)															//
#include		<Arduino.h>																			//
#else																								//
#include		<WProgram.h>																		//
#endif																								//
																									//
#include		<memorysaver.h>																		//	Подключаем файл «хранитель памяти»									(внутри файла есть комментарий поясняющий как сэкономить память программ)
#include		<iarduino_Metro_I2C.h>																//	Подключаем файл iarduino_Metro_I2C.h - для работы с шиной I2C		(используя функции структуры iI2C)
iarduino_I2C	objI2C;																				//	Создаём объект для работы с шиной I2C
																									//
#define			PIN_ARDUINO_ADR			12															//	Номер вывода Arduino используемый для установки адреса первого модуля.
#define			MEM_ARDUINO_FREE		250															//	Количество байт ОЗУ которое требуется оставить свободными при формировании массива объектов Metro.
																									//
#define			DEF_ADDRESS				0x09														//	Адрес модулей на шине I2C по умолчанию (адрес устанавливаемый при наличии 1 на входе PIN_ADDRES)
#define			DEF_CHIP_ID				0xC3														//	ID линейки чипов - константа для всех чипов (позволяет идентифицировать принадлежность чипа к линейке)
#define			REG_FLAGS_0				0x00														//	Адрес регистра флагов управления для чтения
#define			REG_BITS_0				0x01														//	Адрес регистра битов  управления для чтения и записи
#define			REG_FLAGS_1				0x02														//	Адрес регистра флагов управления для чтения
#define			REG_BITS_1				0x03														//	Адрес регистра битов  управления для чтения и записи
#define			REG_MODEL				0x04														//	Адрес регистра содержащего номер типа модуля
#define			REG_VERSION				0x05														//	Адрес регистра содержащего версию прошивки
#define			REG_ADDRESS				0x06														//	Адрес регистра содержащего текущий адрес модуля на шине I2C. Если адрес указан с флагом IF-PIN-ADDRES то адрес установится (и запишется в регистр) только при наличии 1 на входе PIN_ADDRES.
#define			REG_CHIP_ID				0x07														//	Адрес регистра содержащего ID линейки чипов. По данному ID можно определить принадлежность чипа к линейки iarduino.
#define			REG_WRITE				0x08														//	Адрес регистра для записи (первый)
#define			REG_DATA				0x10														//	Адрес регистра флагов для чтения и записи, далее следуют регистры данных
#define			NOT2					0xFFFF														//	Значение соответствующее отсутствию агрумента функции
#define			NOT4					0xFFFFFFFFL													//	Значение соответствующее отсутствию агрумента функции
																									//
#define			MOD_KEY					1															//	Тип модуля - Кнопка
#define			MOD_RGB					2															//	Тип модуля - Светодиод
#define			MOD_RES					3															//	Тип модуля - Потенциометр (переменный резистор)
#define			MOD_BUZ					4															//	Тип модуля - Звукоизлучатель
#define			MOD_DHT					5															//	Тип модуля - Датчик влажности и температуры
#define			MOD_DSL					6															//	Тип модуля - Датчик света
#define			MOD_8X8					8															//	Тип модуля - Светодиодная матрица 8x8
																									//
#define			KEY_PUSHED				1															//	Параметр для функции read()     - вернуть событие   «нажимается».
#define			KEY_RELEASED			2															//	Параметр для функции read()     - вернуть событие   «отпускается».
#define			KEY_PRESSED				3															//	Параметр для функции read()     - вернуть состояние «нажата».
#define			KEY_TRIGGER				4															//	Параметр для функции read()     - вернуть состояние «переключилась».
#define			KEY_HOLD3				5															//	Параметр для функции read()     - вернуть состояние «удерживается» дольше чем время TIME_HOLD1.
#define			KEY_HOLD2				6															//	Параметр для функции read()     - вернуть состояние «удерживается» дольше чем время TIME_HOLD2.
#define			KEY_HOLD1				7															//	Параметр для функции read()     - вернуть состояние «удерживается» дольше чем время TIME_HOLD3.
#define			KEY_CHANGED				8															//	Параметр для функции read()     - вернуть событие   «состояние изменилось».
#define			KEY_TIME				9															//	Параметр для функции read()     - вернуть время удержания текущего состояния кнопки «нажата»/«отпущена».
#define			KEY_SUM					10															//	Параметр для функции read()     - вернуть количество нажатий на кнопку после последнего обращения к данной функции.
#define			RES_ADC					1															//	Параметр для функции read()     - вернуть угол поворота потенциометра.
#define			RES_CHANGED				2															//	Параметр для функции read()     - вернуть событие   «изменился угол поворота потенциометра».
#define			DHT_TEMPERATURE			1															//	Параметр для функции read()     - вернуть значение  температуры.
#define			DHT_HUMIDITY			2															//	Параметр для функции read()     - вернуть значение  влажности.
#define			DHT_CHANGED_TEM			3															//	Параметр для функции read()     - вернуть событие   «изменилась температура».
#define			DHT_CHANGED_HUM			4															//	Параметр для функции read()     - вернуть событие   «изменилась влажность».
#define			DSL_LUX					1															//	Параметр для функции read()     - вернуть значение  освещённости в лк.
#define			DSL_CHANGED				2															//	Параметр для функции read()     - вернуть событие   «освещённость изменилась».
#define			X8_ANGLE_0				96															//	Параметр для функций on()       - повернуть дисплей на   0° по часовой стрелке, изображение повернётся но не изменится.
#define			X8_ANGLE_90				97															//	Параметр для функций on()       - повернуть дисплей на  90° по часовой стрелке, изображение повернётся но не изменится.
#define			X8_ANGLE_180			98															//	Параметр для функций on()       - повернуть дисплей на 180° по часовой стрелке, изображение повернётся но не изменится.
#define			X8_ANGLE_270			99															//	Параметр для функций on()       - повернуть дисплей на 270° по часовой стрелке, изображение повернётся но не изменится.
#define			X8_EMPTY_RIPPLES		100															//	Параметр для функций on()/off() - анимация ряби        на пустом      фоне.
#define			X8_FILLED_RIPPLES		102															//	Параметр для функций on()/off() - анимация ряби        на закрашенном фоне.
#define			X8_EMPTY_DOWN			104															//	Параметр для функций on()/off() - анимация сверху-вниз на пустом      фоне.
#define			X8_FILLED_DOWN			106															//	Параметр для функций on()/off() - анимация сверху-вниз на закрашенном фоне.
#define			X8_EMPTY_TOP			108															//	Параметр для функций on()/off() - анимация снизу-вверх на пустом      фоне.
#define			X8_FILLED_TOP			110															//	Параметр для функций on()/off() - анимация снизу-вверх на закрашенном фоне.
																									//
class iarduino_Metro_BASE{																			//	Определяем полиморфный класс.										(этот класс используется только для изначального создания объекта objClass)
	public:																							//
		virtual bool	begin			(int=NOT2, int=NOT2	);										//	Объявляем функцию инициализации модуля.
		virtual int		test			(int=NOT2, int=NOT2	);										//	Объявляем функцию тестирования  модуля.
		virtual bool	action			(int=NOT2, int=NOT2	);										//	Объявляем функцию выполнения действий.
		virtual long	getVar			(int=NOT2			);										//	Объявляем функцию получения значений переменных.
		virtual void	setVar			(int=NOT2, int=NOT2	);										//	Объявляем функцию передачи  значений переменных.
};																									//
																									//
#include		<iarduino_Metro_KEY.h>																//	Подключаем файл iarduino_Metro_KEY.h - для работы с кнопкой.
#include		<iarduino_Metro_RGB.h>																//	Подключаем файл iarduino_Metro_RGB.h - для работы с RGB светодиодом.
#include		<iarduino_Metro_RES.h>																//	Подключаем файл iarduino_Metro_RES.h - для работы с потенциометром (переменным регистором).
#include		<iarduino_Metro_BUZ.h>																//	Подключаем файл iarduino_Metro_BUZ.h - для работы с звукоизлучателем.
#include		<iarduino_Metro_DHT.h>																//	Подключаем файл iarduino_Metro_DHT.h - для работы с датчиком влажности и температуры.
#include		<iarduino_Metro_DSL.h>																//	Подключаем файл iarduino_Metro_DSL.h - для работы с датчиком света.
#include		<iarduino_Metro_8X8.h>																//	Подключаем файл iarduino_Metro_8X8.h - для работы с матрицей из светодиодов 8х8.
																									//
class iarduino_Metro{																				//
																									//
	public:																							//
	/**	Конструктор класса: **/																		//
		iarduino_Metro(uint8_t i=0){																//	Конструктор основного класса.										(аргументы: i - тип модуля (MOD_KEY - кнопка, MOD_RGB - светодиод, ...) )
			model = i;																				//	Сохраняем тип модуля.
			switch(model){																			//	Выбираем тип модуля с которым предстоит работать через объект данного класса.
				#ifndef Metro_Disable_KEY															//	Если не объявлена константа запрещающая использование данного модуля, то ...
				case MOD_KEY:	objClass = new iarduino_Metro_KEY;	break;							//	Присваиваем указателю objClass ссылку на новый объект производного класса в соответствии с атрибутом указанным при объявлении объекта данного класса.
				#endif																				//
				#ifndef Metro_Disable_RGB															//	Если не объявлена константа запрещающая использование данного модуля, то ...
				case MOD_RGB:	objClass = new iarduino_Metro_RGB;	break;							//	Присваиваем указателю objClass ссылку на новый объект производного класса в соответствии с атрибутом указанным при объявлении объекта данного класса.
				#endif																				//
				#ifndef Metro_Disable_RES															//	Если не объявлена константа запрещающая использование данного модуля, то ...
				case MOD_RES:	objClass = new iarduino_Metro_RES;	break;							//	Присваиваем указателю objClass ссылку на новый объект производного класса в соответствии с атрибутом указанным при объявлении объекта данного класса.
				#endif																				//
				#ifndef Metro_Disable_BUZ															//	Если не объявлена константа запрещающая использование данного модуля, то ...
				case MOD_BUZ:	objClass = new iarduino_Metro_BUZ;	break;							//	Присваиваем указателю objClass ссылку на новый объект производного класса в соответствии с атрибутом указанным при объявлении объекта данного класса.
				#endif																				//
				#ifndef Metro_Disable_DHT															//	Если не объявлена константа запрещающая использование данного модуля, то ...
				case MOD_DHT:	objClass = new iarduino_Metro_DHT;	break;							//	Присваиваем указателю objClass ссылку на новый объект производного класса в соответствии с атрибутом указанным при объявлении объекта данного класса.
				#endif																				//
				#ifndef Metro_Disable_DSL															//	Если не объявлена константа запрещающая использование данного модуля, то ...
				case MOD_DSL:	objClass = new iarduino_Metro_DSL;	break;							//	Присваиваем указателю objClass ссылку на новый объект производного класса в соответствии с атрибутом указанным при объявлении объекта данного класса.
				#endif																				//
				#ifndef Metro_Disable_8X8															//	Если не объявлена константа запрещающая использование данного модуля, то ...
				case MOD_8X8:	objClass = new iarduino_Metro_8X8;	break;							//	Присваиваем указателю objClass ссылку на новый объект производного класса в соответствии с атрибутом указанным при объявлении объекта данного класса.
				#endif																				//
			}																						//
		}																							//
																									//
	/**	Функции доступные пользователю: **/															//
		bool		begin		(int	i0=NOT2														){									return						objClass -> begin	(i0, int(address)		);	}		//	Инициируем работу с модулем.
		int			test		(int	i0=NOT2														){									return						objClass -> test	(i0, int(address)		);	}		//	Инициируем самотестирование модуля.
		int			read		(int	i0=NOT2														){	switch(model){	/************	Кнопка:						**/														//
																														case MOD_KEY:								objClass -> action	(1,  int(address)		);			//	Читаем данные с кнопки.
																																		switch(i0){																			//	Возвращаем только требуемое значение:
																																			case KEY_PUSHED:		return int(	objClass -> getVar	(0			));	break;	//	Возвращаем событие кнопка нажимается.
																																			case KEY_RELEASED:		return int(	objClass -> getVar	(1			));	break;	//	Возвращаем событие кнопка отпускается.
																																			case KEY_PRESSED:		return int(	objClass -> getVar	(2			));	break;	//	Возвращаем состояние кнопка нажата.
																																			case KEY_TRIGGER:		return int(	objClass -> getVar	(3			));	break;	//	Возвращаем состояние кнопка переключилась.
																																			case KEY_HOLD3:			return int(	objClass -> getVar	(4			));	break;	//	Возвращаем флаг удержания кнопки дольше времени TIME_HOLD3.
																																			case KEY_HOLD2:			return int(	objClass -> getVar	(5			));	break;	//	Возвращаем флаг удержания кнопки дольше времени TIME_HOLD2.
																																			case KEY_HOLD1:			return int(	objClass -> getVar	(6			));	break;	//	Возвращаем флаг удержания кнопки дольше времени TIME_HOLD1.
																																			case KEY_CHANGED:		return int(	objClass -> getVar	(7			));	break;	//	Возвращаем состояние кнопки изменилось.
																																			case KEY_TIME:			return int(	objClass -> getVar	(8			));	break;	//	Возвращаем время удержания/простоя кнопки.
																																			case KEY_SUM:			return int(	objClass -> getVar	(9			));	break;	//	Возвращаем количество нажатий на кнопку.
																																			default:				return int(	objClass -> getVar	(2			));	break;	//	Возвращаем состояние кнопка нажата.
																																		}																					//
																														break;
																														/************	Светодиод:					**/
																														case MOD_RGB:	return 		  				0;
																														break;
																														/************	Потенциометр:				**/
																														case MOD_RES:								objClass -> action	(1,  int(address)		);			//	Читаем данные с потенциометра.
																																		switch(i0){																			//	Возвращаем только требуемое значение:
																																			case RES_ADC:			return int(	objClass -> getVar	(0			));	break;	//	Возвращаем значение АЦП.
																																			case RES_CHANGED:		return int(	objClass -> getVar	(1			));	break;	//	Возвращаем событие АЦП изменилось.
																																			default:				return int(	objClass -> getVar	(0			));	break;	//	Возвращаем значение АЦП.
																																		}																					//
																														break;
																														/************	Звукоизлучатель:			**/
																														case MOD_BUZ:	return 		  				0;
																														break;
																														/************	Датчик влажн и темпер-ры:	**/
																														case MOD_DHT:								objClass -> action	(1,  int(address)		);			//	Читаем данные с датчика влажности и температуры.
																																		switch(i0){																			//	Возвращаем только требуемое значение:
																																			case DHT_CHANGED_TEM:	return int(	objClass -> getVar	(0			));	break;	//	Возвращаем событие температура изменилась.
																																			case DHT_CHANGED_HUM:	return int(	objClass -> getVar	(1			));	break;	//	Возвращаем событие влажность изменилась.
																																			case DHT_TEMPERATURE:	return int(	objClass -> getVar	(2			));	break;	//	Возвращаем значение температуры.
																																			case DHT_HUMIDITY:		return int(	objClass -> getVar	(3			));	break;	//	Возвращаем значение влажности.
																																			default:				return int(	objClass -> getVar	(2			));	break;	//	Возвращаем значение температуры.
																																		}																					//
																														break;
																														/************	Датчик освещённости:		**/
																														case MOD_DSL:								objClass -> action	(1,  int(address)		);			//	Читаем данные с датчик света.
																																		switch(i0){																			//	Возвращаем только требуемое значение:
																																			case DSL_LUX:			return int(	objClass -> getVar	(0			));	break;	//	Возвращаем значение освещённости в лк.
																																			case DSL_CHANGED:		return int(	objClass -> getVar	(1			));	break;	//	Возвращаем событие освещённость изменилась.
																																			default:				return int(	objClass -> getVar	(0			));	break;	//	Возвращаем значение освещённости в лк.
																																		}																					//
																														break;
																														/************	Светодиодная матрица:		**/
																														case MOD_8X8:	return 		  				0;
																														break;
																														/************	Неизвестный модуль:			**/
																														default:		return						0;
																														break;
																									}}
		bool		off			(int	i0=NOT2														){	switch(model){	/************	Кнопка:						**/
																														case MOD_KEY:	return 		  				0;
																														break;
																														/************	Светодиод:					**/
																														case MOD_RGB:	return 		  				objClass -> action	(0,  int(address)		);			//	Отключаем светодиод.
																														break;
																														/************	Потенциометр:				**/
																														case MOD_RES:	return 		  				0;
																														break;
																														/************	Звукоизлучатель:			**/
																														case MOD_BUZ:	return 		  				objClass -> action	(0,  int(address)		);			//	Отключаем звукоизлучатель.
																														break;
																														/************	Датчик влажн и темпер-ры:	**/
																														case MOD_DHT:	return 		  				0;
																														break;
																														/************	Датчик освещённости:		**/
																														case MOD_DSL:	return 		  				0;
																														break;
																														/************	Светодиодная матрица:		**/
																														case MOD_8X8:	if(i0>=100 && i0<=255)	{ 	objClass -> setVar	(1,  int(i0)-100+4		);	}		//	Если параметр функции off() лежит в диапазоне 100 ... 255, значит нужно выключить дисплей с функцией, тогда передаём номер функции анимации.
																																		else					{	objClass -> setVar	(1,  0					);	}		//	Иначе, если параметр функции отсутствует или находится вне указанного диапазона, значит нужно просто выключить дисплей, тогда сбрасываем значение переменной хранящей номер функции анимации.
																																									objClass -> setVar	(0,  0					);			//	Передаём адрес массива равный 0, это значит требуется сбросить в 0 все биты массива.
																																									objClass -> setVar	(5,  0					);			//	Останавливаем автопрокрутку.
																																		return 		 				objClass -> action	(0,  int(address)		);			//	Выключаем дисплей.
																														break;
																														/************	Неизвестный модуль:			**/
																														default:		return						0;
																														break;
																									}}
		bool		on			(long	i0=NOT4,	int	i1=NOT2,	int	i2=NOT2,	int	i3=NOT2		){	switch(model){	/************	Кнопка:						**/
																														case MOD_KEY:	return 		  				0;
																														break;
																														/************	Светодиод:					**/
																														case MOD_RGB:	if(i0==NOT4)			{	i0=0xFFFFFFL;									}		//	Если функция on() запущена без параметров, то включаем белый цвет.
																																		if(i0>0xFFFFFFL)		{	objClass -> setVar	(0,  int(i0&0xFFL)		);	}		//	Передаём номер цветовой функции, которую требуется выполнить.
																																		else					{	objClass -> setVar	(0,  0					);	}		//	Передаём номер цветовой функции = 0 (не выполнять цветовые функции).
																																									objClass -> setVar	(1,  int(i0>>16) & 0xFF	);			//	Передаём коэффициент заполнения ШИМ для канала красного цвета: 0...255   = 0   ... 100  %
																																									objClass -> setVar	(2,  int(i0>> 8) & 0xFF	);			//	Передаём коэффициент заполнения ШИМ для канала зелёного цвета: 0...255   = 0   ... 100  %
																																									objClass -> setVar	(3,  int(i0    ) & 0xFF	);			//	Передаём коэффициент заполнения ШИМ для канала синего   цвета: 0...255   = 0   ... 100  %
																																									objClass -> setVar	(4,  i1					);			//	Передаём время длительности свечения:                          0...25500 = 0,0 ... 25,5 сек.
																																									objClass -> setVar	(5,  i2					);			//	Передаём время паузы между свечением:                          0...25500 = 0,0 ... 25,5 сек.
																																									objClass -> setVar	(6,  i3					);			//	Передаём количество миганий:                                   0...255   = 0   ... 255  раз.
																																		return 		 				objClass -> action	(1,  int(address)		);			//	Включаем светодиод.
																														break;
																														/************	Потенциометр:				**/
																														case MOD_RES:	return 		  				0;
																														break;
																														/************	Звукоизлучатель:			**/
																														case MOD_BUZ:	if(i0==NOT4)			{	i0=2700L;										}		//	Если функция on() запущена без параметров, то включаем тон 2,7 кГц.
																																		if(i0>0xFFFFFFL)		{	objClass -> setVar	(0,  int(i0&0xFFL)		);	}		//	Передаём номер мелодии которую требуется воспроизвести.
																																		else					{	objClass -> setVar	(0,  0					);	}		//	Передаём номер мелодии  = 0 (не воспроизводить мелодии).
																																									objClass -> setVar	(1,  int(i0		 )		);			//	Передаём частоту тонального сигнала:                           0...32767 =  0...32767 Гц.
																																									objClass -> setVar	(2,  i1					);			//	Передаём время длительности тонального сигнала:                0...25500 =  0,0...25,5 сек.
																																									objClass -> setVar	(3,  i2					);			//	Передаём время паузы между тональными сигналами:               0...25500 =  0,0...25,5 сек.
																																									objClass -> setVar	(4,  i3					);			//	Передаём количество повторов тональных сигналов:               0...255   =  0...255 раз.
																																		return 		 				objClass -> action	(1,  int(address)		);			//	Включаем мелодию.
																														break;
																														/************	Датчик влажн и темпер-ры:	**/
																														case MOD_DHT:	return 		  				0;
																														break;
																														/************	Датчик освещённости:		**/
																														case MOD_DSL:	return 		  				0;
																														break;
																														/************	Светодиодная матрица:		**/
																														case MOD_8X8:								objClass -> setVar	(5,  0					);			//	Останавливаем автопрокрутку.
																																		if(i0>=0   && i0<=10 )	{	objClass -> setVar	(2,  i0					);			//	Если функция on() запущена c параметром в диапазоне 0   ... 10 , значит требуется изменить яркость       , тогда передаём указанную яркость.
																																		return						objClass -> action	(2,  int(address)		);	}		//	Если функция on() запущена c параметром в диапазоне 0   ... 10 , значит требуется изменить яркость       , тогда выполняем действие установки яркости дисплея.
																																		if(i0>=96  && i0<=99 )	{	objClass -> setVar	(3,  i0					);			//	Если функция on() запущена c параметром в диапазоне 96  ... 99 , значит требуется повернуть дисплей      , тогда передаём указанный угол поворота.
																																		return						objClass -> action	(3,  int(address)		);	}		//	Если функция on() запущена c параметром в диапазоне 96  ... 99 , значит требуется повернуть дисплей      , тогда выполняем действие установки угла поворота дисплея.
																																									objClass -> setVar	(1,  0					);			//	Сбрасываем значение переменной хранящей номер функции анимации.
																																		if(i0==NOT4			 )	{	objClass -> setVar	(0,  1					);	}		//	Если функция on() запущена без параметров                      , значит нужно включить весь дисплей      , тогда передаём адрес массива равный 1, это значит требуется установить в 1 все биты массива.
																																		if(i0> 255			 )	{ 	objClass -> setVar	(0,  int(i0)			);	}		//	Если первый параметр функции on() лежит за пределом 255        , значит первый параметр является массивом, тогда передаём адрес массива который требуется вывести.
																																		if(i0>=100 && i0<=255)	{ 	objClass -> setVar	(0,  1					);			//	Если первый параметр функции on() лежит в диапазоне 100 ... 255, значит нужно включить дисплей с функцией, тогда передаём адрес массива равный 1, это значит требуется установить в 1 все биты массива.
																																									objClass -> setVar	(1,  int(i0)-100+3		);	}		//	Если первый параметр функции on() лежит в диапазоне 100 ... 255, значит нужно включить дисплей с функцией, тогда передаём номер функции анимации.
																																		if(i1>=100 && i1<=255)	{	objClass -> setVar	(1,  int(i1)-100+3		);	}		//	Если второй параметр функции on() лежит в диапазоне 100 ... 255, значит нужно вывести изобр-ие с функцией, тогда передаём номер функции анимации.
																																		return 		 				objClass -> action	(1,  int(address)		);			//	Выводим изображение массива на дисплей.
																														break;
																														/************	Неизвестный модуль:			**/
																														default:		return						0;
																														break;
																									}}
		bool		set			(String i0,			int	i1=NOT2,	int	i2=NOT2						){	uint16_t i3=i0.length()+1; char i4[i3]; i0.getBytes(i4, i3); if(i3>2){set(&i4, i1, i2);}else{set(i4[0]);}	}
		bool		set			(int	i0=NOT2,	int	i1=NOT2,	int	i2=NOT2						){	switch(model){	/************	Кнопка:						**/
																														case MOD_KEY:								objClass -> setVar	(0,  i0					);			//	Передаём время TIME_HOLD_1 требуемое для установки флага HOLD_1: 0...25500 = 0,0...25,5 сек.
																																									objClass -> setVar	(1,  i1					);			//	Передаём время TIME_HOLD_2 требуемое для установки флага HOLD_2: 0...25500 = 0,0...25,5 сек.
																																									objClass -> setVar	(2,  i2					);			//	Передаём время TIME_HOLD_3 требуемое для установки флага HOLD_3: 0...25500 = 0,0...25,5 сек.
																																		return 		 				objClass -> action	(0,  int(address)		);			//	Устанавливаем время TIME_HOLD_X для флагов HOLD_X.
																														break;
																														/************	Светодиод:					**/
																														case MOD_RGB:	return 		  				0;
																														break;
																														/************	Потенциометр:				**/
																														case MOD_RES:								objClass -> setVar	(0,  i0					);			//	Передаём значение АЦП требуемое для установки флага CHANGED: 1 ... 255.
																																		return 		 				objClass -> action	(0,  int(address)		);			//	Устанавливаем значение АЦП для флага CHANGED.
																														break;
																														/************	Звукоизлучатель:			**/
																														case MOD_BUZ:	return 		  				0;
																														break;
																														/************	Датчик влажн и темпер-ры:	**/
																														case MOD_DHT:								objClass -> setVar	(0,  i0					);			//	Передаём температуру требуемую для установки флага CHANGED_TEM:	0 ... 25 = 0 ... 25,0 °C.
																																									objClass -> setVar	(1,  i1					);			//	Передаём влажность   требуемую для установки флага CHANGED_HUM:	0 ... 25 = 0 ... 25,0  %.
																																		return 		 				objClass -> action	(0,  int(address)		);			//	Устанавливаем температуру и влажность для флагов CHANGED_X.
																														break;
																														/************	Датчик освещённости:		**/
																														case MOD_DSL:								objClass -> setVar	(0,  i0					);			//	Передаём значение освещённости требуемое для установки флага CHANGED: 1 ... 255 лк.
																																		return 		 				objClass -> action	(0,  int(address)		);			//	Устанавливаем значение освещённости для флага CHANGED.
																														break;
																														/************	Светодиодная матрица:		**/
																														case MOD_8X8:	if(i0!=NOT2 && i1==NOT2){	objClass -> setVar	(5,  0					);			//	Если указан только 1 параметр функции set(), значит указан код символа, тогда останавливаем автопрокрутку.
																																									objClass -> setVar	(7,  int(i0)			);			//	Если указан только 1 параметр функции set(), значит указан код символа, тогда передаём указанный код символа.
																																		return 		 				objClass -> action	(7,  int(address)		);	}		//	Если указан только 1 параметр функции set(), значит указан код символа, тогда записываем переданный код символа в модуль.
																																		if(i0!=NOT2 && i1!=NOT2){	objClass -> setVar	(5,  0					);			//	Если указан 1 и 2 параметры функции set(), значит указан текст бегущей строки, тогда останавливаем автопрокрутку.
																																									objClass -> setVar	(6,  int(i0)			);			//	Если указан 1 и 2 параметры функции set(), значит указан текст бегущей строки, тогда передаём адрес начала текста в ОЗУ.
																																			if 		 			(	objClass -> action	(6,  int(address)		)	){		//	Если текст записан в модуль, то ...
																																				if(i2==NOT2)  	{	objClass -> setVar	(4,  0					);	}		//	Если не указан третий параметр функции set(), значит время паузы между прокрутками бегущей строки не указано, тогда передаём время 0.0 сек.
																																				else			{	objClass -> setVar	(4,  int(i2)			);	}		//	Если    указан третий параметр функции set(), значит время паузы между прокрутками бегущей строки    указано, тогда передаём указанное время.
																																									objClass -> action	(4,  int(address)		);			//	Если    указан второй параметр функции set(), тогда записываем переданное время паузы в модуль.
																																									objClass -> setVar	(5,  int(i1)			);			//	Если    указан второй параметр функции set(), значит скорость прокрутки бегущей строки    указана, тогда передаём указанную скорость.
																																									objClass -> action	(5,  int(address)		);			//	Если    указан второй параметр функции set(), тогда записываем переданную скорость в модуль.
																																					return 1;														}		//	
																																			else {	return 0;	}													}		//	
																														break;
																														/************	Неизвестный модуль:			**/
																														default:		return						0;
																														break;
																									}}
		bool		frequency	(int	i0=NOT2														){	switch(model){	/************	Кнопка:						**/
																														case MOD_KEY:	return 		  				0;
																														break;
																														/************	Светодиод:					**/
																														case MOD_RGB:								objClass -> setVar	(7,  i0					);			//	Передаём значение частоты ШИМ для всех каналов цветов: 0...255 = 0...255 Гц.
																																		return 		  				objClass -> action	(2,  int(address)		);			//	устанавливаем частоту ШИМ.
																														break;
																														/************	Потенциометр:				**/
																														case MOD_RES:	return 		  				0;
																														break;
																														/************	Звукоизлучатель:			**/
																														case MOD_BUZ:	return 		  				0;
																														break;
																														/************	Датчик влажн и темпер-ры:	**/
																														case MOD_DHT:	return 		  				0;
																														break;
																														/************	Датчик освещённости:		**/
																														case MOD_DSL:	return 		  				0;
																														break;
																														/************	Светодиодная матрица:		**/
																														case MOD_8X8:	return 		  				0;
																														break;
																														/************	Неизвестный модуль:			**/
																														default:		return						0;
																														break;
																									}}
																									//
	/**	Переменные доступные пользователю: **/														//
		uint8_t		address = 0;																	//	Адрес модуля на шине I2C.
		uint8_t		model   = 0;																	//	Тип модуля (MOD_KEY - кнопка, MOD_RGB - светодиод, ...).
		uint8_t		version = 0;																	//	Версия прошивки модуля.
		uint8_t		size    = 0;																	//	Количество ОЗУ занимаемого экземпляром класса.
	private:																						//
																									//
	/**	Внутренние переменные **/																	//
		int			result;																			//	Результат выполнения функций.
		iarduino_Metro_BASE		*objClass;															//	Объявляем указатель на объект полиморфного класса.			(функции данного класса будут переопределены, т.к. указателю будет присвоена ссылка на производный класс)
};		iarduino_Metro			*Metro;																//	Объявляем указатель на объект основного класса библиотеки.	(далее указатель будет ссылаться на массив объектов основного класа)
																									//
//	Функция начальной инициализации модулей:														//
uint8_t iarduino_Metro_Start(uint8_t pinAddres = PIN_ARDUINO_ADR){									//	В качестве аргумента функции можно указать номер вывода к которому подключен вход PIN_ADDRES первого модуля.
			pinMode(pinAddres, OUTPUT);																//	Переводим вывод pinAddres в режим выхода.
			digitalWrite(pinAddres, LOW);															//	Устанавливаем низкий логический уровень на выходе pinAddres.
			objI2C.begin(100);																		//	Инициируем работу по шине I2C на скорости 100 кГц.
			uint8_t Module_Another[127];															//	Объявляем массив для хранения адресов сторонних модулей на шине I2C.
			uint8_t Module_Another_SUM=0;															//	Определяем переменную для хранения количества сторонних модулей на шине I2C.
			uint8_t Module_Metro[127];																//	Объявляем массив для хранения адресов модулей на шине I2C принадлежащих линейке.
			uint8_t Module_Metro_SUM=0;																//	Определяем переменную для хранения количества модулей на шине I2C принадлежащих линейке.
			uint8_t i,j,k,f;																		//	Объявляем временные переменные.
		//	Устанавливаем адрес DEF_ADDRESS всем модулям линейки на шине I2C:						//
			digitalWrite(pinAddres, HIGH);	delay(5);												//	Устанавливаем высокий логический уровень на выходе pinAddres, тогда первый модуль примет адрес DEF_ADDRESS.
			digitalWrite(pinAddres, LOW);	delay(5);												//	Устанавливаем низкий логический уровень на выходе pinAddres.
			for(i=1; i<255; i++){																	//	Проходим по всем адресам на шине I2C.
				objI2C.writeByte(DEF_ADDRESS, REG_BITS_0, 1);	delay(5);							//	Указываем модулю с адресом DEF_ADDRESS установить 1 на выходе PIN_OUTPUT, тогда следующий модуль примет адрес DEF_ADDRESS.
			}	objI2C.writeByte(DEF_ADDRESS, REG_BITS_0, 0);	delay(5);							//	Указываем модулю с адресом DEF_ADDRESS установить 0 на выходе PIN_OUTPUT.
		//	Определяем адреса всех сторонних модулей на шине I2C:									//
			for(i=1; i<127; i++){																	//	Проходим по всем адресам на шине I2C
				if(i!=DEF_ADDRESS){																	//	Пропуская адрес DEF_ADDRESS
					if(objI2C.checkAddress(i)){														//	Если на шине I2C есть устройство с адресом i, то ...
						Module_Another[Module_Another_SUM]=i; Module_Another_SUM++;					//	Добавляем указанный адрес в очередной элемент массива Module_Another и увеличиваем счётчик количества сторонних модулей на шине I2C.
					}	delay(5);																	//	Устанавливаем задержку между запросами.
				}																					//
			}																						//
		//	Переназначаем адреса модулям линейки:													//
			i=DEF_ADDRESS;																			//	Присваиваем переменной i адрес DEF_ADDRESS.
			objI2C.writeByte(DEF_ADDRESS, REG_BITS_0, 0);											//	Указываем всем модулям с адресом DEF_ADDRESS установить 0 на своём выходе PIN_OUTPUT (на случай, если у какого нибудь модуля уже была установлена 1).
			delay(5);																				//	Устанавливаем задержку, дав модулям установить 0 на выходе и понять, что 0 установлен и на входе (т.к. выход предыдущего модуля соеденён со входом следующего).
			do{	k=i;																				//	Сохраняем адрес i в переменную k.
			//	Определяем новый адрес для очередного модуля в переменную i:						//
				do{i++; f=0; for(j=0; j<Module_Another_SUM; j++){if(i==Module_Another[j]){f=1;}}} while(f);	//	Увеличиваем значение i на 1, проверяя его с адресами сторонних модулей, если они совпали то повторяем увеличение i. Так в переменной i появится очередной, уникальный адрес на шине I2C.
				if(i>=127){return 0;}																//	Если очередной свободный адрес на шине I2C вышел за диапазон допустимых значений, то выходим из функции возвращая 0.
			//	Присваиваем адрес i очередному модулю:												//
				j=100;																				//	Определяем количество попыток присвоения нового адреса очередному модулю.
				do{ j--; f=0;																		//	Уменьшаем количество попыток j и сбрасываем флаг f - он будет установлен, если модуль примет новый адрес.
					if(k==DEF_ADDRESS){digitalWrite(pinAddres, HIGH);}								//	Если это первый проход цикла установки адресов, то устанавливаем высокий логический уровень на выходе pinAddres.
					else{objI2C.writeByte(k, REG_BITS_0, 1);}										//	Иначе, указываем модулю с адресом k установить логическую «1» на выходе PIN_OUTPUT.
					delay(5);																		//	Устанавливаем задержку, дав модулю с адресом k установить логическую «1» на выходе, а следующему за ним модулю (с адресом DEF_ADDRESS), понять, что на его входе установилась логическая «1».
					objI2C.writeByte(DEF_ADDRESS, REG_ADDRESS, ((i<<1)|1));							//	Указываем модулю c адресом DEF_ADDRESS сменить свой адрес c DEF_ADDRESS на i, но только в том случае, если на его входе PIN_ADDRES присутствует уровень логической «1».
					delay(50);																		//	Устанавливаем задержку, дав модулю с адресом DEF_ADDRESS и логической «1» на входе, сменить свой адрес на i сохранив его во FLASH памяти.
					if(k==DEF_ADDRESS){digitalWrite(pinAddres, LOW);}								//	Если это первый проход цикла установки адресов, то устанавливаем низкий логический уровень на выходе pinAddres.
					else{objI2C.writeByte(k, REG_BITS_0, 0);}										//	Иначе, указываем модулю с адресом k установить логический «0» на выходе PIN_OUTPUT.
					delay(5);																		//	Устанавливаем задержку, дав модулю с адресом k установить логический «0» на выходе PIN_OUTPUT, а следующему за ним модулю (с адресом i), понять, что на его входе PIN_ADDRES установился логический «0».
					if(objI2C.checkAddress(i)){f=1;}												//	Проверяем, появилось ли на шине I2C устройство с адресом i, если да, то флаг f будет установлен.
				}																					//
				while(f==0 && j>0);																	//	Если флаг f сброшен (модуль не сменил адрес на i) но ещё остались попытки j, то пытаемся сменить адрес повторно.
				delay(5);																			//	Устанавливаем задержку.
				if(f){Module_Metro[Module_Metro_SUM]=i; Module_Metro_SUM++;}						//	Если флаг f установлен (модуль принял адрес), то сохраняем адрес модуля в массив Module_Metro и увеличиваем счётчик найденных модулей линейки Module_Metro_SUM.
			}																						//
			while (f && (objI2C.readByte(i, REG_FLAGS_0)&1)==0);									//	Если флаг f установлен (модуль принял адрес) и на выходе PIN_OUTPUT модуля с адресом i установлен логический 0, значит за ним есть еще модуль, тогда остаёмся цикле установки адресов.
		//	Даём дополнительное время модулям перед началом работы:									//
			delay(100);																				//
		//	Переопределяем массив объектов:															//
			int heapEnd = 0;																		//	Определяем переменную для хранения адреса конца «кучи».
			#if defined(__AVR_ATmega32U4__) | defined(__AVR_ATmega328__) | defined(__AVR_ATmega328P__) | defined(__AVR_ATmega1280__) | defined(__AVR_ATmega1281__) | defined(__AVR_ATmega1284P__) | defined(__AVR_ATmega2560__) | defined(__AVR_ATmega2561__)
				extern int __heap_start, *__brkval;													//	Подключаем переменные для получения адресов начала и конца «кучи».
				heapEnd = (__brkval==0)? (int)&__heap_start : (int)__brkval;						//	Определяем адрес конца «кучи».
				if((heapEnd + MEM_ARDUINO_FREE + sizeof(iarduino_Metro)*Module_Metro_SUM) > int(SP)){return 0;}	//	Если конец кучи + MEM_ARDUINO_FREE байт + изначальное место под массив Metro залезит на стек, то выходим из функции возвращая 0.
			#endif																					//
			Metro = (iarduino_Metro*) malloc(sizeof(iarduino_Metro)*Module_Metro_SUM);				//	Выделяем под массив Metro такой объем памяти при котором количество элементов массива равно количеству найденных модулей линейки Module_Metro_SUM.
			for(i=0; i<Module_Metro_SUM; i++){														//	Проходим по всем найденным модулям линейки.
				j=100;																				//	Определяем количество попыток считывания типа модуля.
				k=0;																				//	Определяем переменную для временного хранения типа модуля.
				do{ k = objI2C.readByte(Module_Metro[i], REG_MODEL); j--; delay(5); }				//	Считываем тип модуля k и уменьшаем количество попыток j.
				while( k==0 && j>0 );																//	Если тип не определён но остались попытки, то повторяем считывание.
				#if defined(__AVR_ATmega32U4__) | defined(__AVR_ATmega328__) | defined(__AVR_ATmega328P__) | defined(__AVR_ATmega1280__) | defined(__AVR_ATmega1281__) | defined(__AVR_ATmega1284P__) | defined(__AVR_ATmega2560__) | defined(__AVR_ATmega2561__)
					heapEnd = (__brkval==0)? (int)&__heap_start : (int)__brkval;					//	Определяем адрес конца «кучи» до переопределения очередного элемента массива объектов.
					if( (heapEnd+MEM_ARDUINO_FREE ) > int(SP) ){return (i==0?0:(i-1));}				//	Если конец кучи + MEM_ARDUINO_FREE байт залезит на стек, то выходим из функции возвращая количество модулей объекты которых уже были определены (=i-1).
				#endif																				//
				Metro[i]          = k;																//	Переопределяем объект в соответствии с типом модуля.
				Metro[i].address   = Module_Metro[i];												//	Сохраняем адрес модуля.
				Metro[i].version  = objI2C.readByte(Module_Metro[i], REG_VERSION);					//	Сохраняем версию прошивки модуля.
				#if defined(__AVR_ATmega32U4__) | defined(__AVR_ATmega328__) | defined(__AVR_ATmega328P__) | defined(__AVR_ATmega1280__) | defined(__AVR_ATmega1281__) | defined(__AVR_ATmega1284P__) | defined(__AVR_ATmega2560__) | defined(__AVR_ATmega2561__)
					Metro[i].size = ((__brkval==0)? (int)&__heap_start:(int)__brkval)-heapEnd;		//	Определяем размер ОЗУ занимаемый объектом Metro[i] как разница адресов конца «кучи» до и после переопределения объекта Metro[i].
				#endif																				//
				Metro[i].size    += sizeof(iarduino_Metro);											//	Добавляем к полученному размеру размер изначально отведённый под элемент Metro[i] при выделении памяти под массив Metro.
				delay(5);																			//	Устанавливаем задержку.
			}																						//
			return Module_Metro_SUM;																//
}																									//
																									//
#endif																								//