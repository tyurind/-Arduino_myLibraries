																													//
#ifndef iarduino_Metro_8X8_h																						//	Функции работы со звукоизлучателем.
#define iarduino_Metro_8X8_h																						//
																													//
class iarduino_Metro_8X8: public iarduino_Metro_BASE{																//	Определяем производный класс iarduino_Metro_8X8.
	public:																											//
	/**	функции данного производного класса iarduino_Metro_8X8		**/												//
	/**	дублирую функции полиморфного класса iarduino_Metro_BASE	**/												//
																													//
//		Функции не используемые в данном модуле:																	//
		bool	begin			(int i0=NOT2, int i1=NOT2	){return 0;}											//	Инициализация модуля.
		int		test			(int i0=NOT2, int i1=NOT2	){return 0;}											//	Самотестирование модуля.
		long	getVar			(int i0=NOT2				){return 0;}											//	Возврат значений переменных.
																													//
//		Выполняем действия:																							//
		bool	action			(int i0=NOT2, int i1=NOT2	){														//	
								uint8_t data[8] = {0,0,0,0,0,0,0,0};												//	Определяем массив для хранения данных пакетно записываемых в модуль.
								bool    result  = false;															//	Определяем флаг результата возвращаемый функцией action.
								uint8_t sumtry  = 10;																//	Количество попыток чтения/записи.
								if(step_end){																		//	Если установлен флаг step_end значит в данный момент выполняется автопрокрутка бегущей строки, тогда.
								//	Отключаем автопрокрутку бегущей строки:											//
									do{	result = objI2C.writeByte( i1, REG_DATA+14,0);								//	Записываем 0 в регистр REG_DATA+14 (TIME_STEP) модуля с адресом i1.
										sumtry	--;	if(!result){delay(1);}											//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
									}	while		(!result && sumtry>0);											//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									step_end=false; 																//	Сбрасываем флаг step_end.
									delay(10);																		//
								//	Считываем флаги регистра REG_DATA:												//
									do{	result = objI2C.readBytes( i1, REG_DATA, data, 1);							//	Считываем из модуля i1, начиная с регистра REG_DATA, в массив data, 1 байт.
										sumtry	--;	if(!result){delay(1);}											//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
									}	while		(!result && sumtry>0);											//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
								//	Записываем флаги в регистр REG_DATA:											//
									data[0] |= 0b00010000;															//	Устанавливаем в байте data[0] бит очистки дисплея CLEAR_SCR.
									do{	result = objI2C.writeByte( i1, REG_DATA, data[0] );							//	Записываем значение data[0] в регистр REG_DATA модуля с адресом i1.
										sumtry	--;	if(!result){delay(1);}											//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
									}	while		(!result && sumtry>0);											//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									delay(10);																		//
								}																					//
								switch(i0){																			//
								//	Действие № 0 - выключить дисплей:												//
									case 0:																			//
									//	Выполняем анимацию:															//
										if(animation){																//	Если требуется выполнить анимацию, то ...
											do{	result = objI2C.writeByte( i1, REG_DATA+18, animation);				//	Записываем значение animation в регистр REG_DATA+18 (FUNCTIONS) модуля с адресом i1.
												sumtry	--;	if(!result){delay(1);}									//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);									//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											if(result){break;}														//	Если номер анимации передан, то выходим из оператора switch (массив заполнится или сотрётся функцией анимации).
										}																			//
									//	Чистим массив:																//
										for(int i=0; i<8; i++){data[i]=0x00;}										//	Если адрес массива равен 0, то сбрасываем    в 0 все биты массива data.
									//	Записываем массив:															//
										do{	result = objI2C.writeBytes( i1, REG_DATA+1, data, 8);					//	Записываем 8 элементов массива data в модуль с адресом i1, начиная с регистра REG_DATA+1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																			//
								//	Действие № 1 - включить дисплей:												//
									case 1:																			//
									//	Если будет анимация, то предварительно чистим или заливаем дисплей:			//
										if(animation){																//	Если требуется выполнить анимацию, то ...
											if((animation-3)%4==0){													//	Если требуется выполнить анимацию появления на пустом фоне (функции анимации 3, 7, 11, 15, 19, 23, 27, ...), то сначала выполняем функцию № 1 - предварительной очистки дисплея (которая не даст увидеть изображение до анимации появления).
												do{	result = objI2C.writeByte( i1, REG_DATA+18, 1);					//	Записываем 1 в регистр REG_DATA+18 (FUNCTIONS) модуля с адресом i1.
													sumtry	--;	if(!result){delay(1);}								//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
												}	while		(!result && sumtry>0);								//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											}																		//
											if((animation-5)%4==0){													//	Если требуется выполнить анимацию появления на залитом фоне (функции анимации 5, 9, 13, 17, 21, 25, 29, ...), то сначала выполняем функцию № 2 - предварительной заливки дисплея (которая не даст увидеть изображение до анимации появления).
												do{	result = objI2C.writeByte( i1, REG_DATA+18, 2);					//	Записываем 1 в регистр REG_DATA+18 (FUNCTIONS) модуля с адресом i1.
													sumtry	--;	if(!result){delay(1);}								//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
												}	while		(!result && sumtry>0);								//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											}																		//
										}																			//
									//	Заполняем массив:															//
										if(addrArray==0){for(int i=0; i<8; i++){data[i]=0x00;}}else					//	Если адрес массива равен 0, то сбрасываем    в 0 все биты массива data.
										if(addrArray==1){for(int i=0; i<8; i++){data[i]=0xFF;}}else					//	Если адрес массива равен 1, то устанавливаем в 1 все биты массива data.
														{for(int i=0; i<8; i++){data[i]=*(uint8_t*)(addrArray+i);}}	//	Если адрес массива иной   , то заполняем массив data данными начиная с адреса addrArray.
									//	Записываем массив:															//
										do{	result = objI2C.writeBytes( i1, REG_DATA+1, data, 8);					//	Записываем 8 элементов массива data в модуль с адресом i1, начиная с регистра REG_DATA+1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									//	Выполняем анимацию:															//
										if(animation){																//	Если требуется выполнить анимацию, то ...
											do{	result = objI2C.writeByte( i1, REG_DATA+18, animation);				//	Записываем значение animation в регистр REG_DATA+18 (FUNCTIONS) модуля с адресом i1.
												sumtry	--;	if(!result){delay(1);}									//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);									//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
										}																			//
									break;																			//
								//	Действие № 2 - установить яркость дисплея:										//
									case 2:																			//
										do{	result = objI2C.writeByte( i1, REG_WRITE+1, brightness);				//	Записываем значение brightness в регистр REG_WRITE+1 (BRIGHTNESS) модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																			//
								//	Действие № 3 - установить угол поворота дисплея:								//
									case 3:																			//
									//	Считываем флаги регистра REG_DATA:											//
										do{	result = objI2C.readBytes( i1, REG_DATA, data, 1);						//	Считываем из модуля i1, начиная с регистра REG_DATA, в массив data, 1 байт.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
										if(!result){break;}															//	Если чтение не удалось то выходим из оператора switch.
									//	Меняем флаги поворота дисплея:												//
										data[0] &= 0b00111111;														//
										data[0] |= (angle<<6);														//
									//	Записываем флаги в регистр REG_DATA:										//
										do{	result = objI2C.writeByte( i1, REG_DATA, data[0]);						//	Записываем значение data[0] в регистр REG_DATA модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																			//
								//	Действие № 4 - установить время паузы между прокрутками бегущей строки:			//
									case 4:																			//
										do{	result = objI2C.writeByte( i1, REG_DATA+15, time_pause);				//	Записываем значение time_pause в регистр REG_DATA+15 (TIME_PAUSE) модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																			//
								//	Действие № 5 - установить скорость прокрутки бегущей строки:					//
									case 5:																			//
										do{	result = objI2C.writeByte( i1, REG_DATA+14, time_step);					//	Записываем значение time_step в регистр REG_DATA+14 (TIME_STEP) модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																			//
								//	Действие № 6 - загрузить текст бегущей строки:									//
									case 6:																			//
									//	Считываем флаги регистра REG_DATA:											//
										sumtry=10;																	//	Устанавливаем количество попыток чтения/записи.
										do{	result = objI2C.readBytes( i1, REG_DATA, data, 1);						//	Считываем из модуля i1, начиная с регистра REG_DATA, в массив data, 1 байт.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
										if(!result){break;}															//	Если чтение не удалось то выходим из оператора switch.
									//	Записываем флаги в регистр REG_DATA:										//
										sumtry=10;																	//	Устанавливаем количество попыток чтения/записи.
										data[0] |= 0b00001000;														//	Устанавливаем в байте data[0] бит очистки строки CLEAR_STR.
										do{	result = objI2C.writeByte( i1, REG_DATA, data[0] );						//	Записываем значение data[0] в регистр REG_DATA модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
										if(!result){break;}															//	Если запись не удалась то выходим из оператора switch.
									//	Ждём очистки строки (сброса флага CLEAR_STR в регистре REG_DATA):			//
										do{	result = objI2C.readBytes( i1, REG_DATA, data, 1); delay(10);			//	Считываем из модуля i1, начиная с регистра REG_DATA, в массив data, 1 байт и ждём.
										}	while		(!result || data[0]&0b00001000 );							//	Повторяем чтение если оно завершилось неудачей или установлен флаг CLEAR_STR в регистре REG_DATA.
									//	Записываем в модуль текст бегущей строки:									//
										lenString = 0;																//	Определяем номер записываемого символа бегущей строки.
										do{	data[0] = *(uint8_t*)(addrString+lenString); lenString++;				//	Получаем код очередного символа из ОЗУ по адресу addrString+lenString (начало строки + номер символа).
										//	Записываем код очередного символа в регистр TEXT_INPUT:					//
                                            objI2C.writeByte( i1, REG_DATA+11, data[0] );                           //  Записываем значение data[0] в регистр REG_DATA+11 модуля с адресом i1.
										//	Ждём очистки регистра TEXT_INPUT:										//
											do{	result=objI2C.readBytes(i1, REG_DATA+11, &data[1], 1); delay(10);	//	Считываем из модуля i1, начиная с регистра REG_DATA+11, в элемент массива data[1] по ссылке на него, 1 байт и ждём.
											}	while	(!result || data[1]>0 );									//	Повторяем чтение если оно завершилось неудачей или данные регистра TEXT_INPUT не стёрлись.
											
										}	while		(lenString<512 && data[0]>0);								//	Продолжаем посимвольную запись текста бегущей строки пока не достигнута максимальная длина или не достигнут символ конца строки.
									//	Записываем нулевое (начальное) положение бегущей строки:					//
										sumtry=10;																	//	Устанавливаем количество попыток чтения/записи.
										do{	result = objI2C.writeByte( i1, REG_DATA+12, 0 );						//	Записываем 0 в регистр REG_DATA+12 модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while	(!result && sumtry>0);											//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
										sumtry=10;																	//	Устанавливаем количество попыток чтения/записи.
										do{	result = objI2C.writeByte( i1, REG_DATA+13, 0 );						//	Записываем 0 в регистр REG_DATA+13 модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while	(!result && sumtry>0);											//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																			//
								//	Действие № 7 - вывести символ на экран:											//
									case 7:																			//
										do{	result = objI2C.writeByte( i1, REG_DATA+10, val_char );					//	Записываем значение val_char в регистр SYMBOL_INPUT модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while	(!result && sumtry>0);											//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
									break;																			//
								}																					//
								return result;																		//
		}																											//
																													//
//		Получаем значение переменных:																				//
		void	setVar			(int i0=NOT2, int i1=NOT2	){														//
								bool f = bool(time_step);															//	Устанавливаем флаг f если сейчас выполняется автопрокрутка.
								switch(i0){																			//
									case 0:	addrArray	= 			uint16_t(i1);		break;						//	Получаем адрес ОЗУ начала данных для массива матрицы:			256...65535		Если адрес = 0 или 1 значит все биты массива нужно установить в 0 или 1.
									case 1: animation	= 			uint8_t (i1);		break;						//	Получаем номер анимации:										0...155
									case 2:	brightness	= map(i1,0,10,0,255);			break;						//	Получаем яркость дисплея:										0...10		=	0...255 ШИМ
									case 3:	angle		= 			uint8_t	(i1)-96;	break;						//	Получаем угол поворота дисплея:									96...99		=	0...3
									case 4:	time_pause	= uint8_t (	uint16_t(i1)/100 );	break;						//	Получаем время паузы между прокрутками бегущей строки:			0...25500	=	0,0...25,5 сек.
									case 5:	time_step	= 256 -		uint8_t (i1);		break;						//	Получаем время между сдвигом пикселей бегущей строки:			255...1 , 0	=	0,01...2,55 , 0 сек.
									case 6:	addrString	= 			uint16_t(i1);		break;						//	Получаем адрес ОЗУ начала данных для бегущей строки:			256...65535
									case 7:	val_char	= 			uint8_t(i1);		break;						//	Получаем код символа для вывода на дисплей:						0...255
								}																					//
								if(f){ if(time_step==0){ step_end = true; }}										//	Если автопрокрутка выполнялась, а теперь нет, то устанавливаем флаг step_end.
		}																											//
																													//
	private:																										//
	/**	Внутренние переменные **/																					//
		int			time_on;																						//	Объявляем переменную для хранения времени длительности тонального сигнала:					0...255     =  0,0...25,5 сек.
		int			time_off;																						//	Объявляем переменную для хранения времени паузы между тональными сигналами:					0...255     =  0,0...25,5 сек.
		int			melody;																							//	Объявляем переменную для хранения номера воспроизводимой мелодии:							0...255     =  0...255   мелодия.
		
		uint16_t	addrArray;																						//	Объявляем переменную для хранения адреса массива с данными для вывода на дисплей.			Если адрес  =  0 значит дисплей требуется закрасить (установить все биты матрицы в 1).
		uint8_t		animation;																						//	Объявляем переменную для хранения номера выполняемой анимации.								Если адрес  =  0 значит дисплей требуется закрасить (установить все биты матрицы в 1).
		uint8_t		brightness;																						//	Объявляем переменную для хранения яркости дисплея:											0...255     =  0...255 ШИМ
		uint8_t		angle;																							//	Объявляем переменную для хранения угла поворота дисплея:									0...3       =  0°,90°,180°,270°
		uint8_t		time_pause;																						//	Объявляем переменную для хранения времени паузы между прокрутками бегущей строки:			0...255     =  0,0...25,5 сек.
		uint8_t		time_step;																						//	Объявляем переменную для хранения времени между сдвигом пикселей бегущей строки:			255...1 , 0	=	0,01...2,55 , 0 сек.
		uint16_t	addrString;																						//	Объявляем переменную для хранения адреса массива символов для бегущей строки:				256...65535
		uint8_t		val_char;																						//	Объявляем переменную для хранения кода символа выводимого на дисплей:						0...255
		uint16_t	lenString = 0;																					//	Определяем количество записанных символов бегущей строки.
		bool		step_end=1;																						//	Определяем флаг указывающий на необходимость завершить автопрокрутку бегущей строки.
};																													//
																													//
#endif																												//

/* =======================================================================================================================================================================================================

Действия функций библиотеки:

set('t');                                  - вывести символ.
set(65);                                   - вывести символ по его коду.
set("Текст для прокрутки",скорость);       - ввести текст и однократно отобразить его бегущей строкой. Текст пробегает однократно с задерживаясь на первой и последней букве, после чего дисплей гаснет, как при off().
set("Текст для прокрутки",скорость,пауза); - ввести текст и постоянно  отображать его бегущей строкой. Текст пробегает постоянно  с задерживаясь на первой и последней букве, после чего дисплей гаснет на указанное время паузы и всё повторяется снова.
off();                                     - выключить светодиоды и стереть массив матрицы             TURN=X     FILL_SCR=0 CLEAR_SCR=1 CLEAR_STR=0 STEP_MOD=X ENABLE=X STEP_LEN[14-0]=X                         TIME_STEP[7-0]=X TIME_PAUSE=X
off(анимация от 100 до 255);               - выключить светодиоды с анимайией и стереть массив матрицы 
on();                                      - включить дисплей и закрасить матрицу                      TURN=X     FILL_SCR=1 CLEAR_SCR=0 CLEAR_STR=0 STEP_MOD=0 ENABLE=1 STEP_LEN[14-0]=0                         TIME_STEP[7-0]=0 TIME_PAUSE=0
on(яркость); от 0 до 10                    - установить яркость не меняя изображения                   TURN=X     FILL_SCR=0 CLEAR_SCR=0 CLEAR_STR=0 STEP_MOD=0 ENABLE=1 STEP_LEN[14-0]=0    BRIGHTNESS=яркость   TIME_STEP[7-0]=0 TIME_PAUSE=0
on(поворот); от 96 до 99                   - повернуть дисплей не меняя изображения                    TURN=0...3 FILL_SCR=0 CLEAR_SCR=0 CLEAR_STR=0 STEP_MOD=0 ENABLE=1 STEP_LEN[14-0]=0    BRIGHTNESS=яркость   TIME_STEP[7-0]=0 TIME_PAUSE=0
on(массив);                                - включить дисплей и вывести массив матрицы                 TURN=X     FILL_SCR=0 CLEAR_SCR=0 CLEAR_STR=0 STEP_MOD=0 ENABLE=1 STEP_LEN[14-0]=0                         TIME_STEP[7-0]=0 TIME_PAUSE=0
on(массив, анимация от 100 до 255);        - включить дисплей с анимированным выводом массива матрицы  TURN=X     FILL_SCR=0 CLEAR_SCR=0 CLEAR_STR=0 STEP_MOD=0 ENABLE=1 STEP_LEN[14-0]=0                         TIME_STEP[7-0]=0 TIME_PAUSE=0
on(анимация от 100 до 255);                - включить дисплей с анимацией, без вывода массива матрицы
frequency(частота);                        - установить новую частоту обновления экрана                FREQUENCY = количество кадров в секунду.

Поворот представлен константами:
X8_ANGLE_0									96	- повернуть дисплей на   0° по часовой стрелке, изображение повернётся но не изменится.
X8_ANGLE_90									97	- повернуть дисплей на  90° по часовой стрелке, изображение повернётся но не изменится.
X8_ANGLE_180								98	- повернуть дисплей на 180° по часовой стрелке, изображение повернётся но не изменится.
X8_ANGLE_270								99	- повернуть дисплей на 270° по часовой стрелке, изображение повернётся но не изменится.

Анимации предстиавлены константами:			Таблица сопоставления константы анимации номеру функции регистра FUNCTIONS. Одна и та же константа анимации сопоставляется с разнвми номерами функций.
											on()	off()
X8_EMPTY_RIPPLES							3		4		- анимация ряби        на пустом      фоне (появление из пустого      фона или исчезание в пустой      фон).
X8_FILLED_RIPPLES							5		6		- анимация ряби        на закрашенном фоне (появление из закрашенного фона или исчезание в закрашенный фон).
X8_EMPTY_DOWN								7		8		- анимация сверху-вниз на пустом      фоне (появление из пустого      фона или исчезание в пустой      фон).
X8_FILLED_DOWN								9		10		- анимация сверху-вниз на закрашенном фоне (появление из закрашенного фона или исчезание в закрашенный фон).
X8_EMPTY_TOP								11		12		- анимация снизу-вверх на пустом      фоне (появление из пустого      фона или исчезание в пустой      фон).
X8_FILLED_TOP								13		14		- анимация снизу-вверх на закрашенном фоне (появление из закрашенного фона или исчезание в закрашенный фон).

Функций:									Значения регистра FUNCTIONS для выполнения анимации.
функции предварительной закраски, предварительной очистки и появления изображений не стирают изображение из массива матрицы и не останавливают бегущую строку.
Функции создания анимации исчезания изображения (или строки) стирают изображение из массива матрицы и останавливают бегущую строку (обнуляют регистр TIME_STEP).

                                           0  (0x00) - завершение выполнения любой функции анимации. Все функции (кроме 1 и 2) самостоятельно сбрасывают регистр «FUNCTIONS» в 0 после завершения своей анимации.
                                                     -
                                           1  (0x01) - предварительная очистка  дисплея (Функция не завершается). Изображение находящееся до вызова функции остаётся в буфере, но не отображается пока действует эта функция. В данном режиме можно загружать навые изображения, менять запускать и останавливать строку прокрутки, всё это будет работать, но дисплей будет чист.
                                           2  (0x02) - предварительная закраска дисплея (Функция не завершается). Изображение находящееся до вызова функции остаётся в буфере, но не отображается пока действует эта функция. В данном режиме можно загружать навые изображения, менять запускать и останавливать строку прокрутки, всё это будет работать, но дисплей будет полностью закрашен.
                                                     -
                                           3  (0x03) - Появление    изображения рябью       из пустого      фона. В начале дисплей очищается,     а потом на нём попиксельно проявляется изображение (или бегущая строка) которые были установлены до выполнения этой функции.
                                           4  (0x04) - Исчезновение изображения рябью       в  пустой       фон.  Изображение дисплея (или бегущая строка)       попиксельно исчезает пока не останется пустой фон.
                                           5  (0x05) - Появление    изображения рябью       из закрашенного фона. В начале дисплей закрашивается, а потом на нём попиксельно проявляется изображение (или бегущая строка) которые были установлены до выполнения этой функции.
                                           6  (0x06) - Исчезновение изображения рябью       в  закрашенный  фон.  Изображение дисплея (или бегущая строка)       попиксельно закрашивается пока не закрасится весь дисплей.
                                                     -
                                           7  (0x07) - Появление    изображения сверху-вниз из пустого      фона. В начале дисплей очищается,     а потом на нём построчно   проявляется изображение (или бегущая строка) которые были установлены до выполнения этой функции.
                                           8  (0x08) - Исчезновение изображения сверху-вниз в  пустой       фон.  Изображение дисплея (или бегущая строка)       построчно   исчезает пока не останется пустой фон.
                                           9  (0x09) - Появление    изображения сверху-вниз из закрашенного фона. В начале дисплей закрашивается, а потом на нём построчно   проявляется изображение (или бегущая строка) которые были установлены до выполнения этой функции.
                                           10 (0x0A) - Исчезновение изображения сверху-вниз в  закрашенный  фон.  Изображение дисплея (или бегущая строка)       построчно   закрашивается пока не закрасится весь дисплей.
                                                     -
                                           11 (0x0B) - Появление    изображения снизу-вверх из пустого      фона. В начале дисплей очищается,     а потом на нём построчно   проявляется изображение (или бегущая строка) которые были установлены до выполнения этой функции.
                                           12 (0x0C) - Исчезновение изображения снизу-вверх в  пустой       фон.  Изображение дисплея (или бегущая строка)       построчно   исчезает пока не останется пустой фон.
                                           13 (0x0D) - Появление    изображения снизу-вверх из закрашенного фона. В начале дисплей закрашивается, а потом на нём построчно   проявляется изображение (или бегущая строка) которые были установлены до выполнения этой функции.
                                           14 (0x0E) - Исчезновение изображения снизу-вверх в  закрашенный  фон.  Изображение дисплея (или бегущая строка)       построчно   закрашивается пока не закрасится весь дисплей.

Таблица регистров модуля:

                   ╔══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤═════════════════════════════════════════════════════════════╗
                   ║       7      │       6      │       5      │       4      │       3      │       2      │       1      │       0      │                                                             ║
                   ╠══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪═════════════════════════════════════════════════════════════╣
0x00 REG_FLAGS_0   ║  FLG_RESET   │FLG_SELF_TEST │       -      │       -      │       -      │       -      │GET_PIN_ADDRES│GET_PIN_OUTPUT│ Служебные флаги для чтения.                                 ║
0x01 REG_BITS_0    ║  SET_RESET   │SET_SELF_TEST │       -      │       -      │       -      │       -      │SET_PIN_ADDRES│SET_PIN_OUTPUT│ Служебные флаги для записи.                                 ║
0x02 REG_FLAGS_1   ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для чтения.                                 ║
0x03 REG_BITS_1    ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для записи.                                 ║
                   ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x04 REG_MODEL   █ ║                                                             MODEL  [7-0] = 0x08 - светодиодная матрица 8х8            │ Тип датчика                                                 ║
0x05 REG_VERSION █ ║                                                             VERSION[7-0] = 0x01                                       │ Версия прошивки                                             ║
0x06 REG_ADDRESS   ║                                                             ADDRESS[6-0] = 0x09                        │ IF_PIN_ADDRES│ Текущий адрес на шине                                       ║
0x07 REG_CHIP_ID   ║                                                             CHIP_ID[7-0] = 0xC3                                       │ ID линейки чипов                                            ║
                   ╟───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────╢
0x08 REG_WRITE   █ ║                                                             FREQUENCY[7-0]  = 0x64 = 100 Гц                           │ Частота ШИМ от 10 до 255 Гц                                 ║
0x09 REG_WRITE+1 █ ║                                                             BRIGHTNESS[7-0] = 0xC0 = 192 = 75%                        │ Яркость матрицы от 0 до 255                                 ║
0x0A REG_WRITE+2   ║                                                             WRITE_2[7-0]                                              │ Зарезервирован                                              ║
0x0B REG_WRITE+3   ║                                                             WRITE_3[7-0]                                              │ Зарезервирован                                              ║
0x0C REG_WRITE+4   ║                                                             WRITE_4[7-0]                                              │ Зарезервирован                                              ║
0x0D REG_WRITE+5   ║                                                             WRITE_5[7-0]                                              │ Зарезервирован                                              ║
0x0E REG_WRITE+6   ║                                                             WRITE_6[7-0]                                              │ Зарезервирован                                              ║
0x0F REG_WRITE+7   ║                                                             WRITE_7[7-0]                                              │ Зарезервирован                                              ║
                   ╟─────────────────────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┼─────────────────────────────────────────────────────────────╢
0x10 REG_DATA    █ ║          TURN[1-0]          │   FILL_SCR   │   CLEAR_SCR  │   CLEAR_STR  │   STEP_MOD   │  STEP_ROUTE  │    ENABLE    │ Статусные флаги                                             ║
                 █ ╟─────────────────────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x11 REG_DATA+1  █ ║                                                             ROW_1[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №1 матрицы (верхняя).        ║ (регистр обнуляется сразу после записи значения в матрицу).
0x12 REG_DATA+2  █ ║                                                             ROW_2[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №2 матрицы.                  ║ (регистр обнуляется сразу после записи значения в матрицу).
0x13 REG_DATA+3  █ ║                                                             ROW_3[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №3 матрицы.                  ║ (регистр обнуляется сразу после записи значения в матрицу).
0x14 REG_DATA+4  █ ║                                                             ROW_4[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №4 матрицы.                  ║ (регистр обнуляется сразу после записи значения в матрицу).
0x15 REG_DATA+5  █ ║                                                             ROW_5[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №5 матрицы.                  ║ (регистр обнуляется сразу после записи значения в матрицу).
0x16 REG_DATA+6  █ ║                                                             ROW_6[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №6 матрицы.                  ║ (регистр обнуляется сразу после записи значения в матрицу).
0x17 REG_DATA+7  █ ║                                                             ROW_7[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №7 матрицы.                  ║ (регистр обнуляется сразу после записи значения в матрицу).
0x18 REG_DATA+8  █ ║                                                             ROW_8[7-0]        = 0x00 = 00000000                       │ Состояние светодиодов в строке №8 матрицы (нижняя).         ║ (регистр обнуляется сразу после записи значения в матрицу).
0x19 REG_DATA+9  █ ║                                                             SAVE_AS[7-0]      = 0x00 = 0                              │ Код под которым текущее изображение сохранится в таблицу.   ║ (регистр обнуляется сразу после записи изображения в таблицу символов).
0x1A REG_DATA+10 █ ║                                                             SYMBOL_INPUT[7-0] = 0x00 = 0                              │ Код символа изображение которого требуется отобразить.      ║ (регистр обнуляется сразу после вывода символа в матрицу).
0x1B REG_DATA+11 █ ║                                                             TEXT_INPUT[7-0]   = 0x00 = 0                              │ Посимвольный ввод текста бегущей строки.                    ║ (регистр обнуляется сразу после записи символа в строку буфера).
0x1C REG_DATA+12 █ ╟──────────────┐                                              STEP_LEN[7-0]     = 0x00 = 0                              │ Количество колонок/символов (зависит от STEP_MOD), на кото- ║ (текст сдвигается как только STEP_LEN[14-0]>0, регистры обнуляются сразу после сдвига изображения матрицы).
0x1D REG_DATA+13 █ ║   STEP_ONE   │                                              STEP_LEN[14-8]    = 0x00 = 0                              │ рое нужно сдвинуть строку влево/вправо (зависит от STEP_ONE)║ 
0x1E REG_DATA+14 █ ╟──────────────┘                                              TIME_STEP[7-0]    = 0x00 = 000 = 0,0 сек.                 │ То же что и STEP_LEN[14-0]++, каждые TIME_STEP[7-0] сек.    ║ (время в сотых   долях секунд от 0.0 до 2.55 сек.). Значение 0 - без автопрокрутки. Если нет повторов (TIME_PAUSE=0), то регистр TIME_STEP сбрасывается в 0 по завершении прокрутки всей строки.
0x1F REG_DATA+15 █ ║                                                             TIME_PAUSE[7-0]   = 0x00 = 000 = 0,0 сек.                 │ Время паузы до повторного автосдвига всей бегущей строки.   ║ (время в десятых долях секунд от 0.0 до 25.5 сек.). Значение 0 - без повторов.      Если нет повторов (TIME_PAUSE=0), то регистр TIME_STEP сбрасывается в 0 по завершении прокрутки всей строки.
0x20 REG_DATA+16 █ ║                                                             TIME_START[7-0]   = 0x64 = 100 = 1,0 сек.                 │ Время простоя прокрутки на первом символе текста.           ║ (время в сотых   долях секунд от 0.0 до 2.55 сек.). Значение 0 - без простоя.
0x21 REG_DATA+17 █ ║                                                             TIME_STOP[7-0]    = 0x64 = 100 = 1,0 сек.                 │ Время простоя прокрутки на первом символе текста.           ║ (время в сотых   долях секунд от 0.0 до 2.55 сек.). Значение 0 - без простоя.
0x22 REG_DATA+18 █ ║                                                             FUNCTIONS[7-0]                                            │ Функции анимации (появление/исчезание изображения).         ║ (для запуска анимации нужно записать номер анимации в регистр FUNCTIONS, а для отключения анимации нужно записать 0). Большенство анимации самостоятельно сбрасывают регистр в 0 по завершении.
                   ╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╧═════════════════════════════════════════════════════════════╝

FREQUENCY        - Частота кадровой развёртки (количество кадров в секунду).
BRIGHTNESS       - Яркость дисплея (от 0 до 255).
TURN             - Биты определяющие поворот изображения матрицы по часовой стрелке. Угол поворота = TURN*90°.
FILL_SCR         - Установка бита указывает залить матрицу экрана. Бит аппаратно сбрасывается после выполнения заливки.
CLEAR_SCR        - Установка бита указывает очистить матрицу экрана. Бит аппаратно сбрасывается после выполнения очистки.
CLEAR_STR        - Установка бита указывает стереть все символы из буфера бегущей строки. Бит аппаратно сбрасывается после стирания символов.
STEP_MOD         - Флаг определяющий режим       сдвига бегущей строки (0 - по столбцам, 1 - посимвольно).
STEP_ROUTE       - Флаг определяющий направление сдвига бегущей строки (0 - влево,       1 - вправо).
ENABLE           - Флаг разрешающий вывод изображений дисплея. Сброс данного флага выключит дисплей, но не сотрёт данные матрицы, они останутся в буфере, так что при установке флага на дисплее вновь отобразится информация.
ROW_1-8          - Строки матрицы экрана доступны для записи и чтения.
SAVE_AS          - Сохранение изображения как символа. Запись числа в данный регистр приведёт к сохранению текущего изображения дисплея в таблицу символов под номером указанном в данном регистре. Регистр обнуляется сразу после записи изображения в таблицу символов.
SYMBOL_INPUT     - Вывод на экран изображения символа из таблицы символов по его коду. Регистр обнуляется сразу после вывода символа в матрицу.
TEXT_INPUT       - Посимвольный ввод текста бегущей строки. Поочерёдный ввод кодов символов в данный регистр формирует текст бегущей строки. Регистр обнуляется сразу после записи символа в буфер бегущей строки.
STEP_LEN         - Количество колонок/символов (зависит от STEP_MOD), на которое нужно сдвинуть бегущую строку влево/вправо (зависит от STEP_ONE) на дисплее. Регистры обнуляются сразу после сдвига изображения матрицы.
TIME_STEP        - Время в сотых   долях секунд (от 0 до 255 => от 0.0 сек до 2.55 сек), для осуществления автосдвига бегущей строки (как STEP_LEN++ каждые TIME_STEP сек). Если нет повторов (TIME_PAUSE=0), то регистр TIME_STEP аппаратно сбрасывается по завершении прокрутки всей строки.
TIME_PAUSE       - Время в десятых долях секунд (от 0 до 255 => от 0.0 сек до 25.5 сек), для паузы до повторного автосдвига всей бегущей строки.                            Если нет повторов (TIME_PAUSE=0), то регистр TIME_STEP сбрасывается в 0 по завершении прокрутки всей строки.
TIME_START       - Время в сотых   долях секунд (от 0 до 255 => от 0.0 сек до 2.55 сек), для простоя на первом    символе текста бегущей строки.
TIME_STOP        - Время в сотых   долях секунд (от 0 до 255 => от 0.0 сек до 2.55 сек), для простоя на последнем символе текста бегущей строки.
FUNCTIONS        - Номер функции анимации (появление/исчезание изображения). Сброс регистра отключит анимацию. Большенство функций самостоятельно сбрасывают регистр по завершении анимации.

*/